"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createGapiMock = void 0;
function createGapiMock(setWindowProp) {
    if (setWindowProp === void 0) { setWindowProp = 'gapi'; }
    var nextInteraction;
    var _user = {
        isSignedIn: false,
        scopes: [],
        props: {
            id: undefined,
            name: '',
            givenName: '',
            familyName: '',
            imageUrl: '',
            email: '',
        },
        resolveNextInteraction: function () {
            if (typeof (nextInteraction) === 'function') {
                nextInteraction();
                nextInteraction = undefined;
            }
            else if (!nextInteraction) {
                nextInteraction = Promise.resolve();
            }
        },
    };
    var user = {
        isSignedIn: function (scopes, userProps) {
            var _a, _b;
            if (scopes === void 0) { scopes = []; }
            if (userProps === void 0) { userProps = {}; }
            _user.isSignedIn = true,
                _user.scopes = scopes;
            _user.props = __assign(__assign(__assign({}, _user.props), userProps), { id: (_b = (_a = userProps.id) !== null && _a !== void 0 ? _a : _user.props.id) !== null && _b !== void 0 ? _b : mockId() });
        },
        isNotSignedIn: function (scopes, userProps) {
            if (scopes === void 0) { scopes = []; }
            _user.isSignedIn = false,
                _user.scopes = scopes;
            _user.props = __assign(__assign({}, _user.props), userProps);
        },
        nextInteraction: function () {
            if (!nextInteraction) {
                return new Promise(function (res) { nextInteraction = res; });
            }
            else if (nextInteraction instanceof Promise) {
                var p = nextInteraction;
                nextInteraction = undefined;
                return p;
            }
            throw 'user.nextInteraction() was called multiple times before an interaction happened.\n'
                + 'This was probably not intended.';
        },
    };
    var _discoveryDocs = {};
    var registerDiscoveryDocs = function (o) { return Object.keys(o).forEach(function (k) { return _discoveryDocs[k] = o[k]; }); };
    var _modules = {
        auth2: createAuthModuleMock,
        client: createClientModuleMock,
    };
    var registerModuleMocks = function (o) { return Object.keys(o).forEach(function (k) { return _modules[k] = o[k]; }); };
    var gapi = {
        load: function (modules, then) {
            Promise.all(modules.split(':').map(function (k) { return new Promise(function (res) {
                res();
                if (!gapi[k]) {
                    gapi[k] = _modules[k]
                        ? _modules[k]({ gapi: gapi, user: user, _user: _user, _discoveryDocs: _discoveryDocs })
                        : function (name) { return ({
                            init: function () { return notImplemented("Mock for gapi module \"" + name + "\""); },
                        }); };
                }
                res();
            }); })).then(typeof then === 'function' ? then : then.callback);
        },
    };
    if (setWindowProp) {
        window[setWindowProp] = gapi;
    }
    return { gapi: gapi, user: user, registerModuleMocks: registerModuleMocks, registerDiscoveryDocs: registerDiscoveryDocs };
}
exports.createGapiMock = createGapiMock;
function mockId() {
    return Math.random().toString(10).substr(2, 10);
}
function notImplemented(descr) {
    return descr + " is not implemented yet.";
}
function createAuthModuleMock(_a) {
    var user = _a.user, _user = _a._user;
    var initConfig;
    var authInstance;
    var auth2 = {
        init: function (config) {
            var client_id = config.client_id, _a = config.fetch_basic_profile, fetch_basic_profile = _a === void 0 ? true : _a, _b = config.scope, scope = _b === void 0 ? '' : _b;
            if (!client_id) {
                throw { message: "Missing required parameter 'client_id'" };
            }
            else if (!fetch_basic_profile && !scope) {
                throw { message: "Missing required parameter 'scope'" };
            }
            if (!initConfig) {
                initConfig = { client_id: client_id, fetch_basic_profile: fetch_basic_profile, scope: scope };
            }
            else if (client_id !== initConfig.client_id || fetch_basic_profile !== initConfig.fetch_basic_profile || scope !== initConfig.scope) {
                throw { message: 'gapi.auth2 has been initialized with different options. Consider calling gapi.auth2.getAuthInstance() instead of gapi.auth2.init().' };
            }
            if (!authInstance) {
                var effectiveScope = fetch_basic_profile ? scope + ' openid email profile' : scope;
                authInstance = createAuthInstanceMock(fetch_basic_profile, effectiveScope);
            }
            return authInstance;
        },
        getAuthInstance: function () { return authInstance; },
        authorize: function () { throw notImplemented('auth2.authorize'); },
        enableDebugLogs: function () { throw notImplemented('auth2.enableDebugLogs'); },
    };
    function createAuthInstanceMock(fetch_basic_profile, initScope) {
        var currentUser;
        var isSignedInListeners = [];
        var currentUserListeners = [];
        var auth = {
            then: function (onInit, onFailure) {
                Promise.resolve().then(function () { return onInit(auth); }, function (r) { return onFailure(r); });
            },
            signIn: function (_a) {
                var _b = _a === void 0 ? {} : _a, _c = _b.scope, scope = _c === void 0 ? '' : _c, _d = _b.prompt, prompt = _d === void 0 ? undefined : _d;
                var scopeArray = (initScope !== null && initScope !== void 0 ? initScope : '' + ' ' + scope).split(' ').filter(function (k) { return Boolean(k); });
                return requestScopes(scopeArray, prompt);
            },
            signOut: function () { return new Promise(function (res) {
                var isSignedInChanged = _user.isSignedIn;
                _user.isSignedIn = false;
                currentUser = createCurrentUserMock();
                res(currentUser);
                notifyListeners(isSignedInChanged);
            }); },
            disconnect: function () { return new Promise(function (res) {
                _user.scopes = [];
                auth.signOut().then(function () { return res(); });
            }); },
            currentUser: {
                // currentUser.get() can return undefined on newly initialized GoogleAuth
                get: function () { return currentUser; },
                listen: function (c) { currentUserListeners.push(c); },
            },
            isSignedIn: {
                get: function () { return _user.isSignedIn; },
                listen: function (c) { isSignedInListeners.push(c); },
            },
            grantOfflineAccess: function () { throw notImplemented('GoogleAuth.grantOfflineAccess'); },
            attachClickHandler: function () { throw notImplemented('GoogleAuth.attachClickHandler'); },
        };
        if (_user.isSignedIn) {
            currentUser = createCurrentUserMock();
        }
        return auth;
        function notifyListeners(isSignedInChanged) {
            if (isSignedInChanged) {
                isSignedInListeners.forEach(function (c) { return c(_user.isSignedIn); });
            }
            currentUserListeners.forEach(function (c) { return currentUser && c(currentUser); });
        }
        function requestScopes(scopes, prompt) {
            if (_user.promise) {
                throw 'The behavior when a previous Promise is still pending is unknown - call user.grantsScopes() or user.closesPopup()';
            }
            return _user.promise = new Promise(function (res, rej) {
                function clearInteraction() {
                    delete user.grantsScopes;
                    delete user.closesPopup;
                    Promise.resolve().then(function () { delete _user.promise; });
                }
                user.grantsScopes = function (grantedScopes, userProps) {
                    var _a, _b;
                    if (grantedScopes === void 0) { grantedScopes = true; }
                    if (userProps === void 0) { userProps = {}; }
                    var isSignedInChanged = !_user.isSignedIn;
                    _user.isSignedIn = true;
                    if (grantedScopes === true) {
                        grantedScopes = scopes;
                    }
                    // openid is always added
                    grantedScopes.push('openid');
                    grantedScopes.forEach(function (k) {
                        if (!_user.scopes.includes(k)) {
                            _user.scopes.push(k);
                        }
                        // the module adds these scopes automatically
                        if (k === 'profile' && !_user.scopes.includes('https://www.googleapis.com/auth/userinfo.profile')) {
                            _user.scopes.push('https://www.googleapis.com/auth/userinfo.profile');
                        }
                        else if (k === 'email' && !_user.scopes.includes('https://www.googleapis.com/auth/userinfo.email')) {
                            _user.scopes.push('https://www.googleapis.com/auth/userinfo.email');
                        }
                    });
                    _user.props = __assign(__assign(__assign({}, _user.props), userProps), { id: (_b = (_a = userProps === null || userProps === void 0 ? void 0 : userProps.id) !== null && _a !== void 0 ? _a : _user.props.id) !== null && _b !== void 0 ? _b : mockId() });
                    currentUser = createCurrentUserMock();
                    clearInteraction();
                    res(currentUser);
                    notifyListeners(isSignedInChanged);
                };
                user.deniesAccess = function () {
                    clearInteraction();
                    rej({ error: 'access_denied' });
                };
                user.closesPopup = function () {
                    clearInteraction();
                    rej({ error: 'popup_closed_by_user' });
                };
                if (scopes.every(function (k) { return _user.scopes.includes(k); })) {
                    // if a user granted scopes before, the popup closes automatically
                    if (_user.isSignedIn && prompt && !['consent', 'select_account'].includes(prompt)) {
                        user.grantsScopes();
                    }
                }
                else if (prompt === 'none') {
                    rej({ error_subtype: 'access_denied', error: 'immediate_failed' });
                }
                _user.resolveNextInteraction();
            });
        }
        function createCurrentUserMock() {
            var basicProfile = createBasicProfileMock();
            return {
                getId: function () { var _a; return (_a = _user.props.id) !== null && _a !== void 0 ? _a : ''; },
                isSignedIn: function () { return _user.isSignedIn; },
                getHostedDomain: function () { throw notImplemented('GoogleUser.getHostedDomain'); },
                getGrantedScopes: function () { return _user.isSignedIn
                    // when fetch_basic_profile is true, the user can not login without consenting to these scopes
                    ? _user.scopes.concat(fetch_basic_profile ? ['email', 'openid', 'profile'] : []).join(' ')
                    : ''; },
                getBasicProfile: function () { return basicProfile; },
                getAuthResponse: function () { throw notImplemented('GoogleUser.getHostedDomain'); },
                reloadAuthResponse: function () { throw notImplemented('GoogleUser.getHostedDomain'); },
                hasGrantedScopes: function (scope) { return scope.split(' ').filter(function (k) { return Boolean(k) && !_user.scopes.includes(k); }).length > 0; },
                grant: function (options) {
                    if (options === void 0) { options = {}; }
                    return authInstance && authInstance.signIn(options);
                },
                grantOfflineAccess: function () { throw notImplemented('GoogleUser.getHostedDomain'); },
                disconnect: function () { return authInstance && authInstance.disconnect(); },
            };
            function createBasicProfileMock() {
                return (initConfig === null || initConfig === void 0 ? void 0 : initConfig.fetch_basic_profile)
                    ? {
                        getId: function () { var _a; return (_a = _user.props.id) !== null && _a !== void 0 ? _a : ''; },
                        getName: function () { var _a; return (_a = _user.props.name) !== null && _a !== void 0 ? _a : ''; },
                        getGivenName: function () { var _a; return (_a = _user.props.givenName) !== null && _a !== void 0 ? _a : ''; },
                        getFamilyName: function () { var _a; return (_a = _user.props.familyName) !== null && _a !== void 0 ? _a : ''; },
                        getImageUrl: function () { var _a; return (_a = _user.props.imageUrl) !== null && _a !== void 0 ? _a : ''; },
                        getEmail: function () { var _a; return (_a = _user.props.email) !== null && _a !== void 0 ? _a : ''; },
                    }
                    : {
                        getId: function () { var _a; return (_a = _user.props.id) !== null && _a !== void 0 ? _a : ''; },
                        getName: function () { return ''; },
                        getGivenName: function () { return ''; },
                        getFamilyName: function () { return ''; },
                        getImageUrl: function () { return ''; },
                        getEmail: function () { return ''; },
                    };
            }
        }
    }
    return auth2;
}
function createClientModuleMock(_a) {
    var gapi = _a.gapi, _discoveryDocs = _a._discoveryDocs;
    var client = {
        init: function (_a) {
            var _b = _a.clientId, clientId = _b === void 0 ? undefined : _b, _c = _a.scope, scope = _c === void 0 ? undefined : _c, _d = _a.discoveryDocs, discoveryDocs = _d === void 0 ? [] : _d;
            return new Promise(function (res, rej) {
                var p = [];
                if (scope) {
                    if (gapi.auth2) {
                        p.push(gapi.auth2.init({ client_id: clientId, scope: scope }));
                    }
                    else {
                        throw 'gapi.auth2 not loaded';
                    }
                }
                p.push.apply(p, discoveryDocs.map(function (k) { return new Promise(function (res, rej) {
                    try {
                        if (typeof (_discoveryDocs[k]) === 'function') {
                            _discoveryDocs[k](gapi);
                        }
                        else {
                            throw "Tried to load discoveryDocs " + k + " - use registerDiscoveryDocs to mock discoveryDocs";
                        }
                        res();
                    }
                    catch (e) {
                        rej(e);
                    }
                }); }));
                Promise.all(p).then(function () { return res(); }, function () { return rej(); });
            });
        },
    };
    return client;
}
//# sourceMappingURL=gapiMock.js.map