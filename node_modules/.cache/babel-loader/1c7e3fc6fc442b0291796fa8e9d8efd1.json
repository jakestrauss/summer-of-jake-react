{"ast":null,"code":"// Generated by CoffeeScript 1.12.7\n(function () {\n  var Lexer,\n      SourceMap,\n      base64encode,\n      compile,\n      ext,\n      fn1,\n      formatSourcePosition,\n      fs,\n      getSourceMap,\n      helpers,\n      i,\n      len,\n      lexer,\n      packageJson,\n      parser,\n      path,\n      ref,\n      sourceMaps,\n      sources,\n      vm,\n      withPrettyErrors,\n      hasProp = {}.hasOwnProperty;\n  fs = require('fs');\n  vm = require('vm');\n  path = require('path');\n  Lexer = require('./lexer').Lexer;\n  parser = require('./parser').parser;\n  helpers = require('./helpers');\n  SourceMap = require('./sourcemap');\n  packageJson = require('../../package.json');\n  exports.VERSION = packageJson.version;\n  exports.FILE_EXTENSIONS = ['.coffee', '.litcoffee', '.coffee.md'];\n  exports.helpers = helpers;\n\n  base64encode = function (src) {\n    switch (false) {\n      case typeof Buffer !== 'function':\n        return new Buffer(src).toString('base64');\n\n      case typeof btoa !== 'function':\n        return btoa(encodeURIComponent(src).replace(/%([0-9A-F]{2})/g, function (match, p1) {\n          return String.fromCharCode('0x' + p1);\n        }));\n\n      default:\n        throw new Error('Unable to base64 encode inline sourcemap.');\n    }\n  };\n\n  withPrettyErrors = function (fn) {\n    return function (code, options) {\n      var err;\n\n      if (options == null) {\n        options = {};\n      }\n\n      try {\n        return fn.call(this, code, options);\n      } catch (error) {\n        err = error;\n\n        if (typeof code !== 'string') {\n          throw err;\n        }\n\n        throw helpers.updateSyntaxError(err, code, options.filename);\n      }\n    };\n  };\n\n  sources = {};\n  sourceMaps = {};\n  exports.compile = compile = withPrettyErrors(function (code, options) {\n    var currentColumn, currentLine, encoded, extend, filename, fragment, fragments, generateSourceMap, header, i, j, js, len, len1, map, merge, newLines, ref, ref1, sourceMapDataURI, sourceURL, token, tokens, v3SourceMap;\n    merge = helpers.merge, extend = helpers.extend;\n    options = extend({}, options);\n    generateSourceMap = options.sourceMap || options.inlineMap || options.filename == null;\n    filename = options.filename || '<anonymous>';\n    sources[filename] = code;\n\n    if (generateSourceMap) {\n      map = new SourceMap();\n    }\n\n    tokens = lexer.tokenize(code, options);\n\n    options.referencedVars = function () {\n      var i, len, results;\n      results = [];\n\n      for (i = 0, len = tokens.length; i < len; i++) {\n        token = tokens[i];\n\n        if (token[0] === 'IDENTIFIER') {\n          results.push(token[1]);\n        }\n      }\n\n      return results;\n    }();\n\n    if (!(options.bare != null && options.bare === true)) {\n      for (i = 0, len = tokens.length; i < len; i++) {\n        token = tokens[i];\n\n        if ((ref = token[0]) === 'IMPORT' || ref === 'EXPORT') {\n          options.bare = true;\n          break;\n        }\n      }\n    }\n\n    fragments = parser.parse(tokens).compileToFragments(options);\n    currentLine = 0;\n\n    if (options.header) {\n      currentLine += 1;\n    }\n\n    if (options.shiftLine) {\n      currentLine += 1;\n    }\n\n    currentColumn = 0;\n    js = \"\";\n\n    for (j = 0, len1 = fragments.length; j < len1; j++) {\n      fragment = fragments[j];\n\n      if (generateSourceMap) {\n        if (fragment.locationData && !/^[;\\s]*$/.test(fragment.code)) {\n          map.add([fragment.locationData.first_line, fragment.locationData.first_column], [currentLine, currentColumn], {\n            noReplace: true\n          });\n        }\n\n        newLines = helpers.count(fragment.code, \"\\n\");\n        currentLine += newLines;\n\n        if (newLines) {\n          currentColumn = fragment.code.length - (fragment.code.lastIndexOf(\"\\n\") + 1);\n        } else {\n          currentColumn += fragment.code.length;\n        }\n      }\n\n      js += fragment.code;\n    }\n\n    if (options.header) {\n      header = \"Generated by CoffeeScript \" + this.VERSION;\n      js = \"// \" + header + \"\\n\" + js;\n    }\n\n    if (generateSourceMap) {\n      v3SourceMap = map.generate(options, code);\n      sourceMaps[filename] = map;\n    }\n\n    if (options.inlineMap) {\n      encoded = base64encode(JSON.stringify(v3SourceMap));\n      sourceMapDataURI = \"//# sourceMappingURL=data:application/json;base64,\" + encoded;\n      sourceURL = \"//# sourceURL=\" + ((ref1 = options.filename) != null ? ref1 : 'coffeescript');\n      js = js + \"\\n\" + sourceMapDataURI + \"\\n\" + sourceURL;\n    }\n\n    if (options.sourceMap) {\n      return {\n        js: js,\n        sourceMap: map,\n        v3SourceMap: JSON.stringify(v3SourceMap, null, 2)\n      };\n    } else {\n      return js;\n    }\n  });\n  exports.tokens = withPrettyErrors(function (code, options) {\n    return lexer.tokenize(code, options);\n  });\n  exports.nodes = withPrettyErrors(function (source, options) {\n    if (typeof source === 'string') {\n      return parser.parse(lexer.tokenize(source, options));\n    } else {\n      return parser.parse(source);\n    }\n  });\n\n  exports.run = function (code, options) {\n    var answer, dir, mainModule, ref;\n\n    if (options == null) {\n      options = {};\n    }\n\n    mainModule = require.main;\n    mainModule.filename = process.argv[1] = options.filename ? fs.realpathSync(options.filename) : '<anonymous>';\n    mainModule.moduleCache && (mainModule.moduleCache = {});\n    dir = options.filename != null ? path.dirname(fs.realpathSync(options.filename)) : fs.realpathSync('.');\n    mainModule.paths = require('module')._nodeModulePaths(dir);\n\n    if (!helpers.isCoffee(mainModule.filename) || require.extensions) {\n      answer = compile(code, options);\n      code = (ref = answer.js) != null ? ref : answer;\n    }\n\n    return mainModule._compile(code, mainModule.filename);\n  };\n\n  exports[\"eval\"] = function (code, options) {\n    var Module, _module, _require, createContext, i, isContext, js, k, len, o, r, ref, ref1, ref2, ref3, sandbox, v;\n\n    if (options == null) {\n      options = {};\n    }\n\n    if (!(code = code.trim())) {\n      return;\n    }\n\n    createContext = (ref = vm.Script.createContext) != null ? ref : vm.createContext;\n    isContext = (ref1 = vm.isContext) != null ? ref1 : function (ctx) {\n      return options.sandbox instanceof createContext().constructor;\n    };\n\n    if (createContext) {\n      if (options.sandbox != null) {\n        if (isContext(options.sandbox)) {\n          sandbox = options.sandbox;\n        } else {\n          sandbox = createContext();\n          ref2 = options.sandbox;\n\n          for (k in ref2) {\n            if (!hasProp.call(ref2, k)) continue;\n            v = ref2[k];\n            sandbox[k] = v;\n          }\n        }\n\n        sandbox.global = sandbox.root = sandbox.GLOBAL = sandbox;\n      } else {\n        sandbox = global;\n      }\n\n      sandbox.__filename = options.filename || 'eval';\n      sandbox.__dirname = path.dirname(sandbox.__filename);\n\n      if (!(sandbox !== global || sandbox.module || sandbox.require)) {\n        Module = require('module');\n        sandbox.module = _module = new Module(options.modulename || 'eval');\n\n        sandbox.require = _require = function (path) {\n          return Module._load(path, _module, true);\n        };\n\n        _module.filename = sandbox.__filename;\n        ref3 = Object.getOwnPropertyNames(require);\n\n        for (i = 0, len = ref3.length; i < len; i++) {\n          r = ref3[i];\n\n          if (r !== 'paths' && r !== 'arguments' && r !== 'caller') {\n            _require[r] = require[r];\n          }\n        }\n\n        _require.paths = _module.paths = Module._nodeModulePaths(process.cwd());\n\n        _require.resolve = function (request) {\n          return Module._resolveFilename(request, _module);\n        };\n      }\n    }\n\n    o = {};\n\n    for (k in options) {\n      if (!hasProp.call(options, k)) continue;\n      v = options[k];\n      o[k] = v;\n    }\n\n    o.bare = true;\n    js = compile(code, o);\n\n    if (sandbox === global) {\n      return vm.runInThisContext(js);\n    } else {\n      return vm.runInContext(js, sandbox);\n    }\n  };\n\n  exports.register = function () {\n    return require('./register');\n  };\n\n  if (require.extensions) {\n    ref = this.FILE_EXTENSIONS;\n\n    fn1 = function (ext) {\n      var base;\n      return (base = require.extensions)[ext] != null ? base[ext] : base[ext] = function () {\n        throw new Error(\"Use CoffeeScript.register() or require the coffee-script/register module to require \" + ext + \" files.\");\n      };\n    };\n\n    for (i = 0, len = ref.length; i < len; i++) {\n      ext = ref[i];\n      fn1(ext);\n    }\n  }\n\n  exports._compileFile = function (filename, sourceMap, inlineMap) {\n    var answer, err, raw, stripped;\n\n    if (sourceMap == null) {\n      sourceMap = false;\n    }\n\n    if (inlineMap == null) {\n      inlineMap = false;\n    }\n\n    raw = fs.readFileSync(filename, 'utf8');\n    stripped = raw.charCodeAt(0) === 0xFEFF ? raw.substring(1) : raw;\n\n    try {\n      answer = compile(stripped, {\n        filename: filename,\n        sourceMap: sourceMap,\n        inlineMap: inlineMap,\n        sourceFiles: [filename],\n        literate: helpers.isLiterate(filename)\n      });\n    } catch (error) {\n      err = error;\n      throw helpers.updateSyntaxError(err, stripped, filename);\n    }\n\n    return answer;\n  };\n\n  lexer = new Lexer();\n  parser.lexer = {\n    lex: function () {\n      var tag, token;\n      token = parser.tokens[this.pos++];\n\n      if (token) {\n        tag = token[0], this.yytext = token[1], this.yylloc = token[2];\n        parser.errorToken = token.origin || token;\n        this.yylineno = this.yylloc.first_line;\n      } else {\n        tag = '';\n      }\n\n      return tag;\n    },\n    setInput: function (tokens) {\n      parser.tokens = tokens;\n      return this.pos = 0;\n    },\n    upcomingInput: function () {\n      return \"\";\n    }\n  };\n  parser.yy = require('./nodes');\n\n  parser.yy.parseError = function (message, arg) {\n    var errorLoc, errorTag, errorText, errorToken, token, tokens;\n    token = arg.token;\n    errorToken = parser.errorToken, tokens = parser.tokens;\n    errorTag = errorToken[0], errorText = errorToken[1], errorLoc = errorToken[2];\n\n    errorText = function () {\n      switch (false) {\n        case errorToken !== tokens[tokens.length - 1]:\n          return 'end of input';\n\n        case errorTag !== 'INDENT' && errorTag !== 'OUTDENT':\n          return 'indentation';\n\n        case errorTag !== 'IDENTIFIER' && errorTag !== 'NUMBER' && errorTag !== 'INFINITY' && errorTag !== 'STRING' && errorTag !== 'STRING_START' && errorTag !== 'REGEX' && errorTag !== 'REGEX_START':\n          return errorTag.replace(/_START$/, '').toLowerCase();\n\n        default:\n          return helpers.nameWhitespaceCharacter(errorText);\n      }\n    }();\n\n    return helpers.throwSyntaxError(\"unexpected \" + errorText, errorLoc);\n  };\n\n  formatSourcePosition = function (frame, getSourceMapping) {\n    var as, column, fileLocation, filename, functionName, isConstructor, isMethodCall, line, methodName, source, tp, typeName;\n    filename = void 0;\n    fileLocation = '';\n\n    if (frame.isNative()) {\n      fileLocation = \"native\";\n    } else {\n      if (frame.isEval()) {\n        filename = frame.getScriptNameOrSourceURL();\n\n        if (!filename) {\n          fileLocation = frame.getEvalOrigin() + \", \";\n        }\n      } else {\n        filename = frame.getFileName();\n      }\n\n      filename || (filename = \"<anonymous>\");\n      line = frame.getLineNumber();\n      column = frame.getColumnNumber();\n      source = getSourceMapping(filename, line, column);\n      fileLocation = source ? filename + \":\" + source[0] + \":\" + source[1] : filename + \":\" + line + \":\" + column;\n    }\n\n    functionName = frame.getFunctionName();\n    isConstructor = frame.isConstructor();\n    isMethodCall = !(frame.isToplevel() || isConstructor);\n\n    if (isMethodCall) {\n      methodName = frame.getMethodName();\n      typeName = frame.getTypeName();\n\n      if (functionName) {\n        tp = as = '';\n\n        if (typeName && functionName.indexOf(typeName)) {\n          tp = typeName + \".\";\n        }\n\n        if (methodName && functionName.indexOf(\".\" + methodName) !== functionName.length - methodName.length - 1) {\n          as = \" [as \" + methodName + \"]\";\n        }\n\n        return \"\" + tp + functionName + as + \" (\" + fileLocation + \")\";\n      } else {\n        return typeName + \".\" + (methodName || '<anonymous>') + \" (\" + fileLocation + \")\";\n      }\n    } else if (isConstructor) {\n      return \"new \" + (functionName || '<anonymous>') + \" (\" + fileLocation + \")\";\n    } else if (functionName) {\n      return functionName + \" (\" + fileLocation + \")\";\n    } else {\n      return fileLocation;\n    }\n  };\n\n  getSourceMap = function (filename) {\n    var answer;\n\n    if (sourceMaps[filename] != null) {\n      return sourceMaps[filename];\n    } else if (sourceMaps['<anonymous>'] != null) {\n      return sourceMaps['<anonymous>'];\n    } else if (sources[filename] != null) {\n      answer = compile(sources[filename], {\n        filename: filename,\n        sourceMap: true,\n        literate: helpers.isLiterate(filename)\n      });\n      return answer.sourceMap;\n    } else {\n      return null;\n    }\n  };\n\n  Error.prepareStackTrace = function (err, stack) {\n    var frame, frames, getSourceMapping;\n\n    getSourceMapping = function (filename, line, column) {\n      var answer, sourceMap;\n      sourceMap = getSourceMap(filename);\n\n      if (sourceMap != null) {\n        answer = sourceMap.sourceLocation([line - 1, column - 1]);\n      }\n\n      if (answer != null) {\n        return [answer[0] + 1, answer[1] + 1];\n      } else {\n        return null;\n      }\n    };\n\n    frames = function () {\n      var j, len1, results;\n      results = [];\n\n      for (j = 0, len1 = stack.length; j < len1; j++) {\n        frame = stack[j];\n\n        if (frame.getFunction() === exports.run) {\n          break;\n        }\n\n        results.push(\"    at \" + formatSourcePosition(frame, getSourceMapping));\n      }\n\n      return results;\n    }();\n\n    return err.toString() + \"\\n\" + frames.join('\\n') + \"\\n\";\n  };\n}).call(this);","map":{"version":3,"sources":["/Users/straussj/Documents/react_projects/summer-of-jake/node_modules/coffee-script/lib/coffee-script/coffee-script.js"],"names":["Lexer","SourceMap","base64encode","compile","ext","fn1","formatSourcePosition","fs","getSourceMap","helpers","i","len","lexer","packageJson","parser","path","ref","sourceMaps","sources","vm","withPrettyErrors","hasProp","hasOwnProperty","require","exports","VERSION","version","FILE_EXTENSIONS","src","Buffer","toString","btoa","encodeURIComponent","replace","match","p1","String","fromCharCode","Error","fn","code","options","err","call","error","updateSyntaxError","filename","currentColumn","currentLine","encoded","extend","fragment","fragments","generateSourceMap","header","j","js","len1","map","merge","newLines","ref1","sourceMapDataURI","sourceURL","token","tokens","v3SourceMap","sourceMap","inlineMap","tokenize","referencedVars","results","length","push","bare","parse","compileToFragments","shiftLine","locationData","test","add","first_line","first_column","noReplace","count","lastIndexOf","generate","JSON","stringify","nodes","source","run","answer","dir","mainModule","main","process","argv","realpathSync","moduleCache","dirname","paths","_nodeModulePaths","isCoffee","extensions","_compile","Module","_module","_require","createContext","isContext","k","o","r","ref2","ref3","sandbox","v","trim","Script","ctx","constructor","global","root","GLOBAL","__filename","__dirname","module","modulename","_load","Object","getOwnPropertyNames","cwd","resolve","request","_resolveFilename","runInThisContext","runInContext","register","base","_compileFile","raw","stripped","readFileSync","charCodeAt","substring","sourceFiles","literate","isLiterate","lex","tag","pos","yytext","yylloc","errorToken","origin","yylineno","setInput","upcomingInput","yy","parseError","message","arg","errorLoc","errorTag","errorText","toLowerCase","nameWhitespaceCharacter","throwSyntaxError","frame","getSourceMapping","as","column","fileLocation","functionName","isConstructor","isMethodCall","line","methodName","tp","typeName","isNative","isEval","getScriptNameOrSourceURL","getEvalOrigin","getFileName","getLineNumber","getColumnNumber","getFunctionName","isToplevel","getMethodName","getTypeName","indexOf","prepareStackTrace","stack","frames","sourceLocation","getFunction","join"],"mappings":"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","sourcesContent":["// Generated by CoffeeScript 1.12.7\n(function() {\n  var Lexer, SourceMap, base64encode, compile, ext, fn1, formatSourcePosition, fs, getSourceMap, helpers, i, len, lexer, packageJson, parser, path, ref, sourceMaps, sources, vm, withPrettyErrors,\n    hasProp = {}.hasOwnProperty;\n\n  fs = require('fs');\n\n  vm = require('vm');\n\n  path = require('path');\n\n  Lexer = require('./lexer').Lexer;\n\n  parser = require('./parser').parser;\n\n  helpers = require('./helpers');\n\n  SourceMap = require('./sourcemap');\n\n  packageJson = require('../../package.json');\n\n  exports.VERSION = packageJson.version;\n\n  exports.FILE_EXTENSIONS = ['.coffee', '.litcoffee', '.coffee.md'];\n\n  exports.helpers = helpers;\n\n  base64encode = function(src) {\n    switch (false) {\n      case typeof Buffer !== 'function':\n        return new Buffer(src).toString('base64');\n      case typeof btoa !== 'function':\n        return btoa(encodeURIComponent(src).replace(/%([0-9A-F]{2})/g, function(match, p1) {\n          return String.fromCharCode('0x' + p1);\n        }));\n      default:\n        throw new Error('Unable to base64 encode inline sourcemap.');\n    }\n  };\n\n  withPrettyErrors = function(fn) {\n    return function(code, options) {\n      var err;\n      if (options == null) {\n        options = {};\n      }\n      try {\n        return fn.call(this, code, options);\n      } catch (error) {\n        err = error;\n        if (typeof code !== 'string') {\n          throw err;\n        }\n        throw helpers.updateSyntaxError(err, code, options.filename);\n      }\n    };\n  };\n\n  sources = {};\n\n  sourceMaps = {};\n\n  exports.compile = compile = withPrettyErrors(function(code, options) {\n    var currentColumn, currentLine, encoded, extend, filename, fragment, fragments, generateSourceMap, header, i, j, js, len, len1, map, merge, newLines, ref, ref1, sourceMapDataURI, sourceURL, token, tokens, v3SourceMap;\n    merge = helpers.merge, extend = helpers.extend;\n    options = extend({}, options);\n    generateSourceMap = options.sourceMap || options.inlineMap || (options.filename == null);\n    filename = options.filename || '<anonymous>';\n    sources[filename] = code;\n    if (generateSourceMap) {\n      map = new SourceMap;\n    }\n    tokens = lexer.tokenize(code, options);\n    options.referencedVars = (function() {\n      var i, len, results;\n      results = [];\n      for (i = 0, len = tokens.length; i < len; i++) {\n        token = tokens[i];\n        if (token[0] === 'IDENTIFIER') {\n          results.push(token[1]);\n        }\n      }\n      return results;\n    })();\n    if (!((options.bare != null) && options.bare === true)) {\n      for (i = 0, len = tokens.length; i < len; i++) {\n        token = tokens[i];\n        if ((ref = token[0]) === 'IMPORT' || ref === 'EXPORT') {\n          options.bare = true;\n          break;\n        }\n      }\n    }\n    fragments = parser.parse(tokens).compileToFragments(options);\n    currentLine = 0;\n    if (options.header) {\n      currentLine += 1;\n    }\n    if (options.shiftLine) {\n      currentLine += 1;\n    }\n    currentColumn = 0;\n    js = \"\";\n    for (j = 0, len1 = fragments.length; j < len1; j++) {\n      fragment = fragments[j];\n      if (generateSourceMap) {\n        if (fragment.locationData && !/^[;\\s]*$/.test(fragment.code)) {\n          map.add([fragment.locationData.first_line, fragment.locationData.first_column], [currentLine, currentColumn], {\n            noReplace: true\n          });\n        }\n        newLines = helpers.count(fragment.code, \"\\n\");\n        currentLine += newLines;\n        if (newLines) {\n          currentColumn = fragment.code.length - (fragment.code.lastIndexOf(\"\\n\") + 1);\n        } else {\n          currentColumn += fragment.code.length;\n        }\n      }\n      js += fragment.code;\n    }\n    if (options.header) {\n      header = \"Generated by CoffeeScript \" + this.VERSION;\n      js = \"// \" + header + \"\\n\" + js;\n    }\n    if (generateSourceMap) {\n      v3SourceMap = map.generate(options, code);\n      sourceMaps[filename] = map;\n    }\n    if (options.inlineMap) {\n      encoded = base64encode(JSON.stringify(v3SourceMap));\n      sourceMapDataURI = \"//# sourceMappingURL=data:application/json;base64,\" + encoded;\n      sourceURL = \"//# sourceURL=\" + ((ref1 = options.filename) != null ? ref1 : 'coffeescript');\n      js = js + \"\\n\" + sourceMapDataURI + \"\\n\" + sourceURL;\n    }\n    if (options.sourceMap) {\n      return {\n        js: js,\n        sourceMap: map,\n        v3SourceMap: JSON.stringify(v3SourceMap, null, 2)\n      };\n    } else {\n      return js;\n    }\n  });\n\n  exports.tokens = withPrettyErrors(function(code, options) {\n    return lexer.tokenize(code, options);\n  });\n\n  exports.nodes = withPrettyErrors(function(source, options) {\n    if (typeof source === 'string') {\n      return parser.parse(lexer.tokenize(source, options));\n    } else {\n      return parser.parse(source);\n    }\n  });\n\n  exports.run = function(code, options) {\n    var answer, dir, mainModule, ref;\n    if (options == null) {\n      options = {};\n    }\n    mainModule = require.main;\n    mainModule.filename = process.argv[1] = options.filename ? fs.realpathSync(options.filename) : '<anonymous>';\n    mainModule.moduleCache && (mainModule.moduleCache = {});\n    dir = options.filename != null ? path.dirname(fs.realpathSync(options.filename)) : fs.realpathSync('.');\n    mainModule.paths = require('module')._nodeModulePaths(dir);\n    if (!helpers.isCoffee(mainModule.filename) || require.extensions) {\n      answer = compile(code, options);\n      code = (ref = answer.js) != null ? ref : answer;\n    }\n    return mainModule._compile(code, mainModule.filename);\n  };\n\n  exports[\"eval\"] = function(code, options) {\n    var Module, _module, _require, createContext, i, isContext, js, k, len, o, r, ref, ref1, ref2, ref3, sandbox, v;\n    if (options == null) {\n      options = {};\n    }\n    if (!(code = code.trim())) {\n      return;\n    }\n    createContext = (ref = vm.Script.createContext) != null ? ref : vm.createContext;\n    isContext = (ref1 = vm.isContext) != null ? ref1 : function(ctx) {\n      return options.sandbox instanceof createContext().constructor;\n    };\n    if (createContext) {\n      if (options.sandbox != null) {\n        if (isContext(options.sandbox)) {\n          sandbox = options.sandbox;\n        } else {\n          sandbox = createContext();\n          ref2 = options.sandbox;\n          for (k in ref2) {\n            if (!hasProp.call(ref2, k)) continue;\n            v = ref2[k];\n            sandbox[k] = v;\n          }\n        }\n        sandbox.global = sandbox.root = sandbox.GLOBAL = sandbox;\n      } else {\n        sandbox = global;\n      }\n      sandbox.__filename = options.filename || 'eval';\n      sandbox.__dirname = path.dirname(sandbox.__filename);\n      if (!(sandbox !== global || sandbox.module || sandbox.require)) {\n        Module = require('module');\n        sandbox.module = _module = new Module(options.modulename || 'eval');\n        sandbox.require = _require = function(path) {\n          return Module._load(path, _module, true);\n        };\n        _module.filename = sandbox.__filename;\n        ref3 = Object.getOwnPropertyNames(require);\n        for (i = 0, len = ref3.length; i < len; i++) {\n          r = ref3[i];\n          if (r !== 'paths' && r !== 'arguments' && r !== 'caller') {\n            _require[r] = require[r];\n          }\n        }\n        _require.paths = _module.paths = Module._nodeModulePaths(process.cwd());\n        _require.resolve = function(request) {\n          return Module._resolveFilename(request, _module);\n        };\n      }\n    }\n    o = {};\n    for (k in options) {\n      if (!hasProp.call(options, k)) continue;\n      v = options[k];\n      o[k] = v;\n    }\n    o.bare = true;\n    js = compile(code, o);\n    if (sandbox === global) {\n      return vm.runInThisContext(js);\n    } else {\n      return vm.runInContext(js, sandbox);\n    }\n  };\n\n  exports.register = function() {\n    return require('./register');\n  };\n\n  if (require.extensions) {\n    ref = this.FILE_EXTENSIONS;\n    fn1 = function(ext) {\n      var base;\n      return (base = require.extensions)[ext] != null ? base[ext] : base[ext] = function() {\n        throw new Error(\"Use CoffeeScript.register() or require the coffee-script/register module to require \" + ext + \" files.\");\n      };\n    };\n    for (i = 0, len = ref.length; i < len; i++) {\n      ext = ref[i];\n      fn1(ext);\n    }\n  }\n\n  exports._compileFile = function(filename, sourceMap, inlineMap) {\n    var answer, err, raw, stripped;\n    if (sourceMap == null) {\n      sourceMap = false;\n    }\n    if (inlineMap == null) {\n      inlineMap = false;\n    }\n    raw = fs.readFileSync(filename, 'utf8');\n    stripped = raw.charCodeAt(0) === 0xFEFF ? raw.substring(1) : raw;\n    try {\n      answer = compile(stripped, {\n        filename: filename,\n        sourceMap: sourceMap,\n        inlineMap: inlineMap,\n        sourceFiles: [filename],\n        literate: helpers.isLiterate(filename)\n      });\n    } catch (error) {\n      err = error;\n      throw helpers.updateSyntaxError(err, stripped, filename);\n    }\n    return answer;\n  };\n\n  lexer = new Lexer;\n\n  parser.lexer = {\n    lex: function() {\n      var tag, token;\n      token = parser.tokens[this.pos++];\n      if (token) {\n        tag = token[0], this.yytext = token[1], this.yylloc = token[2];\n        parser.errorToken = token.origin || token;\n        this.yylineno = this.yylloc.first_line;\n      } else {\n        tag = '';\n      }\n      return tag;\n    },\n    setInput: function(tokens) {\n      parser.tokens = tokens;\n      return this.pos = 0;\n    },\n    upcomingInput: function() {\n      return \"\";\n    }\n  };\n\n  parser.yy = require('./nodes');\n\n  parser.yy.parseError = function(message, arg) {\n    var errorLoc, errorTag, errorText, errorToken, token, tokens;\n    token = arg.token;\n    errorToken = parser.errorToken, tokens = parser.tokens;\n    errorTag = errorToken[0], errorText = errorToken[1], errorLoc = errorToken[2];\n    errorText = (function() {\n      switch (false) {\n        case errorToken !== tokens[tokens.length - 1]:\n          return 'end of input';\n        case errorTag !== 'INDENT' && errorTag !== 'OUTDENT':\n          return 'indentation';\n        case errorTag !== 'IDENTIFIER' && errorTag !== 'NUMBER' && errorTag !== 'INFINITY' && errorTag !== 'STRING' && errorTag !== 'STRING_START' && errorTag !== 'REGEX' && errorTag !== 'REGEX_START':\n          return errorTag.replace(/_START$/, '').toLowerCase();\n        default:\n          return helpers.nameWhitespaceCharacter(errorText);\n      }\n    })();\n    return helpers.throwSyntaxError(\"unexpected \" + errorText, errorLoc);\n  };\n\n  formatSourcePosition = function(frame, getSourceMapping) {\n    var as, column, fileLocation, filename, functionName, isConstructor, isMethodCall, line, methodName, source, tp, typeName;\n    filename = void 0;\n    fileLocation = '';\n    if (frame.isNative()) {\n      fileLocation = \"native\";\n    } else {\n      if (frame.isEval()) {\n        filename = frame.getScriptNameOrSourceURL();\n        if (!filename) {\n          fileLocation = (frame.getEvalOrigin()) + \", \";\n        }\n      } else {\n        filename = frame.getFileName();\n      }\n      filename || (filename = \"<anonymous>\");\n      line = frame.getLineNumber();\n      column = frame.getColumnNumber();\n      source = getSourceMapping(filename, line, column);\n      fileLocation = source ? filename + \":\" + source[0] + \":\" + source[1] : filename + \":\" + line + \":\" + column;\n    }\n    functionName = frame.getFunctionName();\n    isConstructor = frame.isConstructor();\n    isMethodCall = !(frame.isToplevel() || isConstructor);\n    if (isMethodCall) {\n      methodName = frame.getMethodName();\n      typeName = frame.getTypeName();\n      if (functionName) {\n        tp = as = '';\n        if (typeName && functionName.indexOf(typeName)) {\n          tp = typeName + \".\";\n        }\n        if (methodName && functionName.indexOf(\".\" + methodName) !== functionName.length - methodName.length - 1) {\n          as = \" [as \" + methodName + \"]\";\n        }\n        return \"\" + tp + functionName + as + \" (\" + fileLocation + \")\";\n      } else {\n        return typeName + \".\" + (methodName || '<anonymous>') + \" (\" + fileLocation + \")\";\n      }\n    } else if (isConstructor) {\n      return \"new \" + (functionName || '<anonymous>') + \" (\" + fileLocation + \")\";\n    } else if (functionName) {\n      return functionName + \" (\" + fileLocation + \")\";\n    } else {\n      return fileLocation;\n    }\n  };\n\n  getSourceMap = function(filename) {\n    var answer;\n    if (sourceMaps[filename] != null) {\n      return sourceMaps[filename];\n    } else if (sourceMaps['<anonymous>'] != null) {\n      return sourceMaps['<anonymous>'];\n    } else if (sources[filename] != null) {\n      answer = compile(sources[filename], {\n        filename: filename,\n        sourceMap: true,\n        literate: helpers.isLiterate(filename)\n      });\n      return answer.sourceMap;\n    } else {\n      return null;\n    }\n  };\n\n  Error.prepareStackTrace = function(err, stack) {\n    var frame, frames, getSourceMapping;\n    getSourceMapping = function(filename, line, column) {\n      var answer, sourceMap;\n      sourceMap = getSourceMap(filename);\n      if (sourceMap != null) {\n        answer = sourceMap.sourceLocation([line - 1, column - 1]);\n      }\n      if (answer != null) {\n        return [answer[0] + 1, answer[1] + 1];\n      } else {\n        return null;\n      }\n    };\n    frames = (function() {\n      var j, len1, results;\n      results = [];\n      for (j = 0, len1 = stack.length; j < len1; j++) {\n        frame = stack[j];\n        if (frame.getFunction() === exports.run) {\n          break;\n        }\n        results.push(\"    at \" + (formatSourcePosition(frame, getSourceMapping)));\n      }\n      return results;\n    })();\n    return (err.toString()) + \"\\n\" + (frames.join('\\n')) + \"\\n\";\n  };\n\n}).call(this);\n"]},"metadata":{},"sourceType":"script"}