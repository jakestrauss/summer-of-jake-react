{"ast":null,"code":"// Generated by CoffeeScript 1.12.7\n(function () {\n  var BALANCED_PAIRS,\n      CALL_CLOSERS,\n      EXPRESSION_CLOSE,\n      EXPRESSION_END,\n      EXPRESSION_START,\n      IMPLICIT_CALL,\n      IMPLICIT_END,\n      IMPLICIT_FUNC,\n      IMPLICIT_UNSPACED_CALL,\n      INVERSES,\n      LINEBREAKS,\n      Rewriter,\n      SINGLE_CLOSERS,\n      SINGLE_LINERS,\n      generate,\n      k,\n      left,\n      len,\n      ref,\n      rite,\n      indexOf = [].indexOf || function (item) {\n    for (var i = 0, l = this.length; i < l; i++) {\n      if (i in this && this[i] === item) return i;\n    }\n\n    return -1;\n  },\n      slice = [].slice;\n\n  generate = function (tag, value, origin) {\n    var tok;\n    tok = [tag, value];\n    tok.generated = true;\n\n    if (origin) {\n      tok.origin = origin;\n    }\n\n    return tok;\n  };\n\n  exports.Rewriter = Rewriter = function () {\n    function Rewriter() {}\n\n    Rewriter.prototype.rewrite = function (tokens1) {\n      this.tokens = tokens1;\n      this.removeLeadingNewlines();\n      this.closeOpenCalls();\n      this.closeOpenIndexes();\n      this.normalizeLines();\n      this.tagPostfixConditionals();\n      this.addImplicitBracesAndParens();\n      this.addLocationDataToGeneratedTokens();\n      this.fixOutdentLocationData();\n      return this.tokens;\n    };\n\n    Rewriter.prototype.scanTokens = function (block) {\n      var i, token, tokens;\n      tokens = this.tokens;\n      i = 0;\n\n      while (token = tokens[i]) {\n        i += block.call(this, token, i, tokens);\n      }\n\n      return true;\n    };\n\n    Rewriter.prototype.detectEnd = function (i, condition, action) {\n      var levels, ref, ref1, token, tokens;\n      tokens = this.tokens;\n      levels = 0;\n\n      while (token = tokens[i]) {\n        if (levels === 0 && condition.call(this, token, i)) {\n          return action.call(this, token, i);\n        }\n\n        if (!token || levels < 0) {\n          return action.call(this, token, i - 1);\n        }\n\n        if (ref = token[0], indexOf.call(EXPRESSION_START, ref) >= 0) {\n          levels += 1;\n        } else if (ref1 = token[0], indexOf.call(EXPRESSION_END, ref1) >= 0) {\n          levels -= 1;\n        }\n\n        i += 1;\n      }\n\n      return i - 1;\n    };\n\n    Rewriter.prototype.removeLeadingNewlines = function () {\n      var i, k, len, ref, tag;\n      ref = this.tokens;\n\n      for (i = k = 0, len = ref.length; k < len; i = ++k) {\n        tag = ref[i][0];\n\n        if (tag !== 'TERMINATOR') {\n          break;\n        }\n      }\n\n      if (i) {\n        return this.tokens.splice(0, i);\n      }\n    };\n\n    Rewriter.prototype.closeOpenCalls = function () {\n      var action, condition;\n\n      condition = function (token, i) {\n        var ref;\n        return (ref = token[0]) === ')' || ref === 'CALL_END' || token[0] === 'OUTDENT' && this.tag(i - 1) === ')';\n      };\n\n      action = function (token, i) {\n        return this.tokens[token[0] === 'OUTDENT' ? i - 1 : i][0] = 'CALL_END';\n      };\n\n      return this.scanTokens(function (token, i) {\n        if (token[0] === 'CALL_START') {\n          this.detectEnd(i + 1, condition, action);\n        }\n\n        return 1;\n      });\n    };\n\n    Rewriter.prototype.closeOpenIndexes = function () {\n      var action, condition;\n\n      condition = function (token, i) {\n        var ref;\n        return (ref = token[0]) === ']' || ref === 'INDEX_END';\n      };\n\n      action = function (token, i) {\n        return token[0] = 'INDEX_END';\n      };\n\n      return this.scanTokens(function (token, i) {\n        if (token[0] === 'INDEX_START') {\n          this.detectEnd(i + 1, condition, action);\n        }\n\n        return 1;\n      });\n    };\n\n    Rewriter.prototype.indexOfTag = function () {\n      var fuzz, i, j, k, pattern, ref, ref1;\n      i = arguments[0], pattern = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n      fuzz = 0;\n\n      for (j = k = 0, ref = pattern.length; 0 <= ref ? k < ref : k > ref; j = 0 <= ref ? ++k : --k) {\n        while (this.tag(i + j + fuzz) === 'HERECOMMENT') {\n          fuzz += 2;\n        }\n\n        if (pattern[j] == null) {\n          continue;\n        }\n\n        if (typeof pattern[j] === 'string') {\n          pattern[j] = [pattern[j]];\n        }\n\n        if (ref1 = this.tag(i + j + fuzz), indexOf.call(pattern[j], ref1) < 0) {\n          return -1;\n        }\n      }\n\n      return i + j + fuzz - 1;\n    };\n\n    Rewriter.prototype.looksObjectish = function (j) {\n      var end, index;\n\n      if (this.indexOfTag(j, '@', null, ':') > -1 || this.indexOfTag(j, null, ':') > -1) {\n        return true;\n      }\n\n      index = this.indexOfTag(j, EXPRESSION_START);\n\n      if (index > -1) {\n        end = null;\n        this.detectEnd(index + 1, function (token) {\n          var ref;\n          return ref = token[0], indexOf.call(EXPRESSION_END, ref) >= 0;\n        }, function (token, i) {\n          return end = i;\n        });\n\n        if (this.tag(end + 1) === ':') {\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    Rewriter.prototype.findTagsBackwards = function (i, tags) {\n      var backStack, ref, ref1, ref2, ref3, ref4, ref5;\n      backStack = [];\n\n      while (i >= 0 && (backStack.length || (ref2 = this.tag(i), indexOf.call(tags, ref2) < 0) && ((ref3 = this.tag(i), indexOf.call(EXPRESSION_START, ref3) < 0) || this.tokens[i].generated) && (ref4 = this.tag(i), indexOf.call(LINEBREAKS, ref4) < 0))) {\n        if (ref = this.tag(i), indexOf.call(EXPRESSION_END, ref) >= 0) {\n          backStack.push(this.tag(i));\n        }\n\n        if ((ref1 = this.tag(i), indexOf.call(EXPRESSION_START, ref1) >= 0) && backStack.length) {\n          backStack.pop();\n        }\n\n        i -= 1;\n      }\n\n      return ref5 = this.tag(i), indexOf.call(tags, ref5) >= 0;\n    };\n\n    Rewriter.prototype.addImplicitBracesAndParens = function () {\n      var stack, start;\n      stack = [];\n      start = null;\n      return this.scanTokens(function (token, i, tokens) {\n        var endImplicitCall, endImplicitObject, forward, inImplicit, inImplicitCall, inImplicitControl, inImplicitObject, isImplicit, isImplicitCall, isImplicitObject, k, newLine, nextTag, offset, prevTag, prevToken, ref, ref1, ref2, ref3, ref4, ref5, s, sameLine, stackIdx, stackItem, stackTag, stackTop, startIdx, startImplicitCall, startImplicitObject, startsLine, tag;\n        tag = token[0];\n        prevTag = (prevToken = i > 0 ? tokens[i - 1] : [])[0];\n        nextTag = (i < tokens.length - 1 ? tokens[i + 1] : [])[0];\n\n        stackTop = function () {\n          return stack[stack.length - 1];\n        };\n\n        startIdx = i;\n\n        forward = function (n) {\n          return i - startIdx + n;\n        };\n\n        isImplicit = function (stackItem) {\n          var ref;\n          return stackItem != null ? (ref = stackItem[2]) != null ? ref.ours : void 0 : void 0;\n        };\n\n        isImplicitObject = function (stackItem) {\n          return isImplicit(stackItem) && (stackItem != null ? stackItem[0] : void 0) === '{';\n        };\n\n        isImplicitCall = function (stackItem) {\n          return isImplicit(stackItem) && (stackItem != null ? stackItem[0] : void 0) === '(';\n        };\n\n        inImplicit = function () {\n          return isImplicit(stackTop());\n        };\n\n        inImplicitCall = function () {\n          return isImplicitCall(stackTop());\n        };\n\n        inImplicitObject = function () {\n          return isImplicitObject(stackTop());\n        };\n\n        inImplicitControl = function () {\n          var ref;\n          return inImplicit && ((ref = stackTop()) != null ? ref[0] : void 0) === 'CONTROL';\n        };\n\n        startImplicitCall = function (j) {\n          var idx;\n          idx = j != null ? j : i;\n          stack.push(['(', idx, {\n            ours: true\n          }]);\n          tokens.splice(idx, 0, generate('CALL_START', '(', ['', 'implicit function call', token[2]]));\n\n          if (j == null) {\n            return i += 1;\n          }\n        };\n\n        endImplicitCall = function () {\n          stack.pop();\n          tokens.splice(i, 0, generate('CALL_END', ')', ['', 'end of input', token[2]]));\n          return i += 1;\n        };\n\n        startImplicitObject = function (j, startsLine) {\n          var idx, val;\n\n          if (startsLine == null) {\n            startsLine = true;\n          }\n\n          idx = j != null ? j : i;\n          stack.push(['{', idx, {\n            sameLine: true,\n            startsLine: startsLine,\n            ours: true\n          }]);\n          val = new String('{');\n          val.generated = true;\n          tokens.splice(idx, 0, generate('{', val, token));\n\n          if (j == null) {\n            return i += 1;\n          }\n        };\n\n        endImplicitObject = function (j) {\n          j = j != null ? j : i;\n          stack.pop();\n          tokens.splice(j, 0, generate('}', '}', token));\n          return i += 1;\n        };\n\n        if (inImplicitCall() && (tag === 'IF' || tag === 'TRY' || tag === 'FINALLY' || tag === 'CATCH' || tag === 'CLASS' || tag === 'SWITCH')) {\n          stack.push(['CONTROL', i, {\n            ours: true\n          }]);\n          return forward(1);\n        }\n\n        if (tag === 'INDENT' && inImplicit()) {\n          if (prevTag !== '=>' && prevTag !== '->' && prevTag !== '[' && prevTag !== '(' && prevTag !== ',' && prevTag !== '{' && prevTag !== 'TRY' && prevTag !== 'ELSE' && prevTag !== '=') {\n            while (inImplicitCall()) {\n              endImplicitCall();\n            }\n          }\n\n          if (inImplicitControl()) {\n            stack.pop();\n          }\n\n          stack.push([tag, i]);\n          return forward(1);\n        }\n\n        if (indexOf.call(EXPRESSION_START, tag) >= 0) {\n          stack.push([tag, i]);\n          return forward(1);\n        }\n\n        if (indexOf.call(EXPRESSION_END, tag) >= 0) {\n          while (inImplicit()) {\n            if (inImplicitCall()) {\n              endImplicitCall();\n            } else if (inImplicitObject()) {\n              endImplicitObject();\n            } else {\n              stack.pop();\n            }\n          }\n\n          start = stack.pop();\n        }\n\n        if ((indexOf.call(IMPLICIT_FUNC, tag) >= 0 && token.spaced || tag === '?' && i > 0 && !tokens[i - 1].spaced) && (indexOf.call(IMPLICIT_CALL, nextTag) >= 0 || indexOf.call(IMPLICIT_UNSPACED_CALL, nextTag) >= 0 && !((ref = tokens[i + 1]) != null ? ref.spaced : void 0) && !((ref1 = tokens[i + 1]) != null ? ref1.newLine : void 0))) {\n          if (tag === '?') {\n            tag = token[0] = 'FUNC_EXIST';\n          }\n\n          startImplicitCall(i + 1);\n          return forward(2);\n        }\n\n        if (indexOf.call(IMPLICIT_FUNC, tag) >= 0 && this.indexOfTag(i + 1, 'INDENT') > -1 && this.looksObjectish(i + 2) && !this.findTagsBackwards(i, ['CLASS', 'EXTENDS', 'IF', 'CATCH', 'SWITCH', 'LEADING_WHEN', 'FOR', 'WHILE', 'UNTIL'])) {\n          startImplicitCall(i + 1);\n          stack.push(['INDENT', i + 2]);\n          return forward(3);\n        }\n\n        if (tag === ':') {\n          s = function () {\n            var ref2;\n\n            switch (false) {\n              case (ref2 = this.tag(i - 1), indexOf.call(EXPRESSION_END, ref2) < 0):\n                return start[1];\n\n              case this.tag(i - 2) !== '@':\n                return i - 2;\n\n              default:\n                return i - 1;\n            }\n          }.call(this);\n\n          while (this.tag(s - 2) === 'HERECOMMENT') {\n            s -= 2;\n          }\n\n          this.insideForDeclaration = nextTag === 'FOR';\n          startsLine = s === 0 || (ref2 = this.tag(s - 1), indexOf.call(LINEBREAKS, ref2) >= 0) || tokens[s - 1].newLine;\n\n          if (stackTop()) {\n            ref3 = stackTop(), stackTag = ref3[0], stackIdx = ref3[1];\n\n            if ((stackTag === '{' || stackTag === 'INDENT' && this.tag(stackIdx - 1) === '{') && (startsLine || this.tag(s - 1) === ',' || this.tag(s - 1) === '{')) {\n              return forward(1);\n            }\n          }\n\n          startImplicitObject(s, !!startsLine);\n          return forward(2);\n        }\n\n        if (indexOf.call(LINEBREAKS, tag) >= 0) {\n          for (k = stack.length - 1; k >= 0; k += -1) {\n            stackItem = stack[k];\n\n            if (!isImplicit(stackItem)) {\n              break;\n            }\n\n            if (isImplicitObject(stackItem)) {\n              stackItem[2].sameLine = false;\n            }\n          }\n        }\n\n        newLine = prevTag === 'OUTDENT' || prevToken.newLine;\n\n        if (indexOf.call(IMPLICIT_END, tag) >= 0 || indexOf.call(CALL_CLOSERS, tag) >= 0 && newLine) {\n          while (inImplicit()) {\n            ref4 = stackTop(), stackTag = ref4[0], stackIdx = ref4[1], (ref5 = ref4[2], sameLine = ref5.sameLine, startsLine = ref5.startsLine);\n\n            if (inImplicitCall() && prevTag !== ',') {\n              endImplicitCall();\n            } else if (inImplicitObject() && !this.insideForDeclaration && sameLine && tag !== 'TERMINATOR' && prevTag !== ':') {\n              endImplicitObject();\n            } else if (inImplicitObject() && tag === 'TERMINATOR' && prevTag !== ',' && !(startsLine && this.looksObjectish(i + 1))) {\n              if (nextTag === 'HERECOMMENT') {\n                return forward(1);\n              }\n\n              endImplicitObject();\n            } else {\n              break;\n            }\n          }\n        }\n\n        if (tag === ',' && !this.looksObjectish(i + 1) && inImplicitObject() && !this.insideForDeclaration && (nextTag !== 'TERMINATOR' || !this.looksObjectish(i + 2))) {\n          offset = nextTag === 'OUTDENT' ? 1 : 0;\n\n          while (inImplicitObject()) {\n            endImplicitObject(i + offset);\n          }\n        }\n\n        return forward(1);\n      });\n    };\n\n    Rewriter.prototype.addLocationDataToGeneratedTokens = function () {\n      return this.scanTokens(function (token, i, tokens) {\n        var column, line, nextLocation, prevLocation, ref, ref1;\n\n        if (token[2]) {\n          return 1;\n        }\n\n        if (!(token.generated || token.explicit)) {\n          return 1;\n        }\n\n        if (token[0] === '{' && (nextLocation = (ref = tokens[i + 1]) != null ? ref[2] : void 0)) {\n          line = nextLocation.first_line, column = nextLocation.first_column;\n        } else if (prevLocation = (ref1 = tokens[i - 1]) != null ? ref1[2] : void 0) {\n          line = prevLocation.last_line, column = prevLocation.last_column;\n        } else {\n          line = column = 0;\n        }\n\n        token[2] = {\n          first_line: line,\n          first_column: column,\n          last_line: line,\n          last_column: column\n        };\n        return 1;\n      });\n    };\n\n    Rewriter.prototype.fixOutdentLocationData = function () {\n      return this.scanTokens(function (token, i, tokens) {\n        var prevLocationData;\n\n        if (!(token[0] === 'OUTDENT' || token.generated && token[0] === 'CALL_END' || token.generated && token[0] === '}')) {\n          return 1;\n        }\n\n        prevLocationData = tokens[i - 1][2];\n        token[2] = {\n          first_line: prevLocationData.last_line,\n          first_column: prevLocationData.last_column,\n          last_line: prevLocationData.last_line,\n          last_column: prevLocationData.last_column\n        };\n        return 1;\n      });\n    };\n\n    Rewriter.prototype.normalizeLines = function () {\n      var action, condition, indent, outdent, starter;\n      starter = indent = outdent = null;\n\n      condition = function (token, i) {\n        var ref, ref1, ref2, ref3;\n        return token[1] !== ';' && (ref = token[0], indexOf.call(SINGLE_CLOSERS, ref) >= 0) && !(token[0] === 'TERMINATOR' && (ref1 = this.tag(i + 1), indexOf.call(EXPRESSION_CLOSE, ref1) >= 0)) && !(token[0] === 'ELSE' && starter !== 'THEN') && !(((ref2 = token[0]) === 'CATCH' || ref2 === 'FINALLY') && (starter === '->' || starter === '=>')) || (ref3 = token[0], indexOf.call(CALL_CLOSERS, ref3) >= 0) && (this.tokens[i - 1].newLine || this.tokens[i - 1][0] === 'OUTDENT');\n      };\n\n      action = function (token, i) {\n        return this.tokens.splice(this.tag(i - 1) === ',' ? i - 1 : i, 0, outdent);\n      };\n\n      return this.scanTokens(function (token, i, tokens) {\n        var j, k, ref, ref1, ref2, tag;\n        tag = token[0];\n\n        if (tag === 'TERMINATOR') {\n          if (this.tag(i + 1) === 'ELSE' && this.tag(i - 1) !== 'OUTDENT') {\n            tokens.splice.apply(tokens, [i, 1].concat(slice.call(this.indentation())));\n            return 1;\n          }\n\n          if (ref = this.tag(i + 1), indexOf.call(EXPRESSION_CLOSE, ref) >= 0) {\n            tokens.splice(i, 1);\n            return 0;\n          }\n        }\n\n        if (tag === 'CATCH') {\n          for (j = k = 1; k <= 2; j = ++k) {\n            if (!((ref1 = this.tag(i + j)) === 'OUTDENT' || ref1 === 'TERMINATOR' || ref1 === 'FINALLY')) {\n              continue;\n            }\n\n            tokens.splice.apply(tokens, [i + j, 0].concat(slice.call(this.indentation())));\n            return 2 + j;\n          }\n        }\n\n        if (indexOf.call(SINGLE_LINERS, tag) >= 0 && this.tag(i + 1) !== 'INDENT' && !(tag === 'ELSE' && this.tag(i + 1) === 'IF')) {\n          starter = tag;\n          ref2 = this.indentation(tokens[i]), indent = ref2[0], outdent = ref2[1];\n\n          if (starter === 'THEN') {\n            indent.fromThen = true;\n          }\n\n          tokens.splice(i + 1, 0, indent);\n          this.detectEnd(i + 2, condition, action);\n\n          if (tag === 'THEN') {\n            tokens.splice(i, 1);\n          }\n\n          return 1;\n        }\n\n        return 1;\n      });\n    };\n\n    Rewriter.prototype.tagPostfixConditionals = function () {\n      var action, condition, original;\n      original = null;\n\n      condition = function (token, i) {\n        var prevTag, tag;\n        tag = token[0];\n        prevTag = this.tokens[i - 1][0];\n        return tag === 'TERMINATOR' || tag === 'INDENT' && indexOf.call(SINGLE_LINERS, prevTag) < 0;\n      };\n\n      action = function (token, i) {\n        if (token[0] !== 'INDENT' || token.generated && !token.fromThen) {\n          return original[0] = 'POST_' + original[0];\n        }\n      };\n\n      return this.scanTokens(function (token, i) {\n        if (token[0] !== 'IF') {\n          return 1;\n        }\n\n        original = token;\n        this.detectEnd(i + 1, condition, action);\n        return 1;\n      });\n    };\n\n    Rewriter.prototype.indentation = function (origin) {\n      var indent, outdent;\n      indent = ['INDENT', 2];\n      outdent = ['OUTDENT', 2];\n\n      if (origin) {\n        indent.generated = outdent.generated = true;\n        indent.origin = outdent.origin = origin;\n      } else {\n        indent.explicit = outdent.explicit = true;\n      }\n\n      return [indent, outdent];\n    };\n\n    Rewriter.prototype.generate = generate;\n\n    Rewriter.prototype.tag = function (i) {\n      var ref;\n      return (ref = this.tokens[i]) != null ? ref[0] : void 0;\n    };\n\n    return Rewriter;\n  }();\n\n  BALANCED_PAIRS = [['(', ')'], ['[', ']'], ['{', '}'], ['INDENT', 'OUTDENT'], ['CALL_START', 'CALL_END'], ['PARAM_START', 'PARAM_END'], ['INDEX_START', 'INDEX_END'], ['STRING_START', 'STRING_END'], ['REGEX_START', 'REGEX_END']];\n  exports.INVERSES = INVERSES = {};\n  EXPRESSION_START = [];\n  EXPRESSION_END = [];\n\n  for (k = 0, len = BALANCED_PAIRS.length; k < len; k++) {\n    ref = BALANCED_PAIRS[k], left = ref[0], rite = ref[1];\n    EXPRESSION_START.push(INVERSES[rite] = left);\n    EXPRESSION_END.push(INVERSES[left] = rite);\n  }\n\n  EXPRESSION_CLOSE = ['CATCH', 'THEN', 'ELSE', 'FINALLY'].concat(EXPRESSION_END);\n  IMPLICIT_FUNC = ['IDENTIFIER', 'PROPERTY', 'SUPER', ')', 'CALL_END', ']', 'INDEX_END', '@', 'THIS'];\n  IMPLICIT_CALL = ['IDENTIFIER', 'PROPERTY', 'NUMBER', 'INFINITY', 'NAN', 'STRING', 'STRING_START', 'REGEX', 'REGEX_START', 'JS', 'NEW', 'PARAM_START', 'CLASS', 'IF', 'TRY', 'SWITCH', 'THIS', 'UNDEFINED', 'NULL', 'BOOL', 'UNARY', 'YIELD', 'UNARY_MATH', 'SUPER', 'THROW', '@', '->', '=>', '[', '(', '{', '--', '++'];\n  IMPLICIT_UNSPACED_CALL = ['+', '-'];\n  IMPLICIT_END = ['POST_IF', 'FOR', 'WHILE', 'UNTIL', 'WHEN', 'BY', 'LOOP', 'TERMINATOR'];\n  SINGLE_LINERS = ['ELSE', '->', '=>', 'TRY', 'FINALLY', 'THEN'];\n  SINGLE_CLOSERS = ['TERMINATOR', 'CATCH', 'FINALLY', 'ELSE', 'OUTDENT', 'LEADING_WHEN'];\n  LINEBREAKS = ['TERMINATOR', 'INDENT', 'OUTDENT'];\n  CALL_CLOSERS = ['.', '?.', '::', '?::'];\n}).call(this);","map":{"version":3,"sources":["/Users/straussj/Documents/react_projects/summer-of-jake/node_modules/coffee-script/lib/coffee-script/rewriter.js"],"names":["BALANCED_PAIRS","CALL_CLOSERS","EXPRESSION_CLOSE","EXPRESSION_END","EXPRESSION_START","IMPLICIT_CALL","IMPLICIT_END","IMPLICIT_FUNC","IMPLICIT_UNSPACED_CALL","INVERSES","LINEBREAKS","Rewriter","SINGLE_CLOSERS","SINGLE_LINERS","generate","k","left","len","ref","rite","indexOf","item","i","l","length","slice","tag","value","origin","tok","generated","exports","prototype","rewrite","tokens1","tokens","removeLeadingNewlines","closeOpenCalls","closeOpenIndexes","normalizeLines","tagPostfixConditionals","addImplicitBracesAndParens","addLocationDataToGeneratedTokens","fixOutdentLocationData","scanTokens","block","token","call","detectEnd","condition","action","levels","ref1","splice","indexOfTag","fuzz","j","pattern","arguments","looksObjectish","end","index","findTagsBackwards","tags","backStack","ref2","ref3","ref4","ref5","push","pop","stack","start","endImplicitCall","endImplicitObject","forward","inImplicit","inImplicitCall","inImplicitControl","inImplicitObject","isImplicit","isImplicitCall","isImplicitObject","newLine","nextTag","offset","prevTag","prevToken","s","sameLine","stackIdx","stackItem","stackTag","stackTop","startIdx","startImplicitCall","startImplicitObject","startsLine","n","ours","idx","val","String","spaced","insideForDeclaration","column","line","nextLocation","prevLocation","explicit","first_line","first_column","last_line","last_column","prevLocationData","indent","outdent","starter","apply","concat","indentation","fromThen","original"],"mappings":"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","sourcesContent":["// Generated by CoffeeScript 1.12.7\n(function() {\n  var BALANCED_PAIRS, CALL_CLOSERS, EXPRESSION_CLOSE, EXPRESSION_END, EXPRESSION_START, IMPLICIT_CALL, IMPLICIT_END, IMPLICIT_FUNC, IMPLICIT_UNSPACED_CALL, INVERSES, LINEBREAKS, Rewriter, SINGLE_CLOSERS, SINGLE_LINERS, generate, k, left, len, ref, rite,\n    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },\n    slice = [].slice;\n\n  generate = function(tag, value, origin) {\n    var tok;\n    tok = [tag, value];\n    tok.generated = true;\n    if (origin) {\n      tok.origin = origin;\n    }\n    return tok;\n  };\n\n  exports.Rewriter = Rewriter = (function() {\n    function Rewriter() {}\n\n    Rewriter.prototype.rewrite = function(tokens1) {\n      this.tokens = tokens1;\n      this.removeLeadingNewlines();\n      this.closeOpenCalls();\n      this.closeOpenIndexes();\n      this.normalizeLines();\n      this.tagPostfixConditionals();\n      this.addImplicitBracesAndParens();\n      this.addLocationDataToGeneratedTokens();\n      this.fixOutdentLocationData();\n      return this.tokens;\n    };\n\n    Rewriter.prototype.scanTokens = function(block) {\n      var i, token, tokens;\n      tokens = this.tokens;\n      i = 0;\n      while (token = tokens[i]) {\n        i += block.call(this, token, i, tokens);\n      }\n      return true;\n    };\n\n    Rewriter.prototype.detectEnd = function(i, condition, action) {\n      var levels, ref, ref1, token, tokens;\n      tokens = this.tokens;\n      levels = 0;\n      while (token = tokens[i]) {\n        if (levels === 0 && condition.call(this, token, i)) {\n          return action.call(this, token, i);\n        }\n        if (!token || levels < 0) {\n          return action.call(this, token, i - 1);\n        }\n        if (ref = token[0], indexOf.call(EXPRESSION_START, ref) >= 0) {\n          levels += 1;\n        } else if (ref1 = token[0], indexOf.call(EXPRESSION_END, ref1) >= 0) {\n          levels -= 1;\n        }\n        i += 1;\n      }\n      return i - 1;\n    };\n\n    Rewriter.prototype.removeLeadingNewlines = function() {\n      var i, k, len, ref, tag;\n      ref = this.tokens;\n      for (i = k = 0, len = ref.length; k < len; i = ++k) {\n        tag = ref[i][0];\n        if (tag !== 'TERMINATOR') {\n          break;\n        }\n      }\n      if (i) {\n        return this.tokens.splice(0, i);\n      }\n    };\n\n    Rewriter.prototype.closeOpenCalls = function() {\n      var action, condition;\n      condition = function(token, i) {\n        var ref;\n        return ((ref = token[0]) === ')' || ref === 'CALL_END') || token[0] === 'OUTDENT' && this.tag(i - 1) === ')';\n      };\n      action = function(token, i) {\n        return this.tokens[token[0] === 'OUTDENT' ? i - 1 : i][0] = 'CALL_END';\n      };\n      return this.scanTokens(function(token, i) {\n        if (token[0] === 'CALL_START') {\n          this.detectEnd(i + 1, condition, action);\n        }\n        return 1;\n      });\n    };\n\n    Rewriter.prototype.closeOpenIndexes = function() {\n      var action, condition;\n      condition = function(token, i) {\n        var ref;\n        return (ref = token[0]) === ']' || ref === 'INDEX_END';\n      };\n      action = function(token, i) {\n        return token[0] = 'INDEX_END';\n      };\n      return this.scanTokens(function(token, i) {\n        if (token[0] === 'INDEX_START') {\n          this.detectEnd(i + 1, condition, action);\n        }\n        return 1;\n      });\n    };\n\n    Rewriter.prototype.indexOfTag = function() {\n      var fuzz, i, j, k, pattern, ref, ref1;\n      i = arguments[0], pattern = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n      fuzz = 0;\n      for (j = k = 0, ref = pattern.length; 0 <= ref ? k < ref : k > ref; j = 0 <= ref ? ++k : --k) {\n        while (this.tag(i + j + fuzz) === 'HERECOMMENT') {\n          fuzz += 2;\n        }\n        if (pattern[j] == null) {\n          continue;\n        }\n        if (typeof pattern[j] === 'string') {\n          pattern[j] = [pattern[j]];\n        }\n        if (ref1 = this.tag(i + j + fuzz), indexOf.call(pattern[j], ref1) < 0) {\n          return -1;\n        }\n      }\n      return i + j + fuzz - 1;\n    };\n\n    Rewriter.prototype.looksObjectish = function(j) {\n      var end, index;\n      if (this.indexOfTag(j, '@', null, ':') > -1 || this.indexOfTag(j, null, ':') > -1) {\n        return true;\n      }\n      index = this.indexOfTag(j, EXPRESSION_START);\n      if (index > -1) {\n        end = null;\n        this.detectEnd(index + 1, (function(token) {\n          var ref;\n          return ref = token[0], indexOf.call(EXPRESSION_END, ref) >= 0;\n        }), (function(token, i) {\n          return end = i;\n        }));\n        if (this.tag(end + 1) === ':') {\n          return true;\n        }\n      }\n      return false;\n    };\n\n    Rewriter.prototype.findTagsBackwards = function(i, tags) {\n      var backStack, ref, ref1, ref2, ref3, ref4, ref5;\n      backStack = [];\n      while (i >= 0 && (backStack.length || (ref2 = this.tag(i), indexOf.call(tags, ref2) < 0) && ((ref3 = this.tag(i), indexOf.call(EXPRESSION_START, ref3) < 0) || this.tokens[i].generated) && (ref4 = this.tag(i), indexOf.call(LINEBREAKS, ref4) < 0))) {\n        if (ref = this.tag(i), indexOf.call(EXPRESSION_END, ref) >= 0) {\n          backStack.push(this.tag(i));\n        }\n        if ((ref1 = this.tag(i), indexOf.call(EXPRESSION_START, ref1) >= 0) && backStack.length) {\n          backStack.pop();\n        }\n        i -= 1;\n      }\n      return ref5 = this.tag(i), indexOf.call(tags, ref5) >= 0;\n    };\n\n    Rewriter.prototype.addImplicitBracesAndParens = function() {\n      var stack, start;\n      stack = [];\n      start = null;\n      return this.scanTokens(function(token, i, tokens) {\n        var endImplicitCall, endImplicitObject, forward, inImplicit, inImplicitCall, inImplicitControl, inImplicitObject, isImplicit, isImplicitCall, isImplicitObject, k, newLine, nextTag, offset, prevTag, prevToken, ref, ref1, ref2, ref3, ref4, ref5, s, sameLine, stackIdx, stackItem, stackTag, stackTop, startIdx, startImplicitCall, startImplicitObject, startsLine, tag;\n        tag = token[0];\n        prevTag = (prevToken = i > 0 ? tokens[i - 1] : [])[0];\n        nextTag = (i < tokens.length - 1 ? tokens[i + 1] : [])[0];\n        stackTop = function() {\n          return stack[stack.length - 1];\n        };\n        startIdx = i;\n        forward = function(n) {\n          return i - startIdx + n;\n        };\n        isImplicit = function(stackItem) {\n          var ref;\n          return stackItem != null ? (ref = stackItem[2]) != null ? ref.ours : void 0 : void 0;\n        };\n        isImplicitObject = function(stackItem) {\n          return isImplicit(stackItem) && (stackItem != null ? stackItem[0] : void 0) === '{';\n        };\n        isImplicitCall = function(stackItem) {\n          return isImplicit(stackItem) && (stackItem != null ? stackItem[0] : void 0) === '(';\n        };\n        inImplicit = function() {\n          return isImplicit(stackTop());\n        };\n        inImplicitCall = function() {\n          return isImplicitCall(stackTop());\n        };\n        inImplicitObject = function() {\n          return isImplicitObject(stackTop());\n        };\n        inImplicitControl = function() {\n          var ref;\n          return inImplicit && ((ref = stackTop()) != null ? ref[0] : void 0) === 'CONTROL';\n        };\n        startImplicitCall = function(j) {\n          var idx;\n          idx = j != null ? j : i;\n          stack.push([\n            '(', idx, {\n              ours: true\n            }\n          ]);\n          tokens.splice(idx, 0, generate('CALL_START', '(', ['', 'implicit function call', token[2]]));\n          if (j == null) {\n            return i += 1;\n          }\n        };\n        endImplicitCall = function() {\n          stack.pop();\n          tokens.splice(i, 0, generate('CALL_END', ')', ['', 'end of input', token[2]]));\n          return i += 1;\n        };\n        startImplicitObject = function(j, startsLine) {\n          var idx, val;\n          if (startsLine == null) {\n            startsLine = true;\n          }\n          idx = j != null ? j : i;\n          stack.push([\n            '{', idx, {\n              sameLine: true,\n              startsLine: startsLine,\n              ours: true\n            }\n          ]);\n          val = new String('{');\n          val.generated = true;\n          tokens.splice(idx, 0, generate('{', val, token));\n          if (j == null) {\n            return i += 1;\n          }\n        };\n        endImplicitObject = function(j) {\n          j = j != null ? j : i;\n          stack.pop();\n          tokens.splice(j, 0, generate('}', '}', token));\n          return i += 1;\n        };\n        if (inImplicitCall() && (tag === 'IF' || tag === 'TRY' || tag === 'FINALLY' || tag === 'CATCH' || tag === 'CLASS' || tag === 'SWITCH')) {\n          stack.push([\n            'CONTROL', i, {\n              ours: true\n            }\n          ]);\n          return forward(1);\n        }\n        if (tag === 'INDENT' && inImplicit()) {\n          if (prevTag !== '=>' && prevTag !== '->' && prevTag !== '[' && prevTag !== '(' && prevTag !== ',' && prevTag !== '{' && prevTag !== 'TRY' && prevTag !== 'ELSE' && prevTag !== '=') {\n            while (inImplicitCall()) {\n              endImplicitCall();\n            }\n          }\n          if (inImplicitControl()) {\n            stack.pop();\n          }\n          stack.push([tag, i]);\n          return forward(1);\n        }\n        if (indexOf.call(EXPRESSION_START, tag) >= 0) {\n          stack.push([tag, i]);\n          return forward(1);\n        }\n        if (indexOf.call(EXPRESSION_END, tag) >= 0) {\n          while (inImplicit()) {\n            if (inImplicitCall()) {\n              endImplicitCall();\n            } else if (inImplicitObject()) {\n              endImplicitObject();\n            } else {\n              stack.pop();\n            }\n          }\n          start = stack.pop();\n        }\n        if ((indexOf.call(IMPLICIT_FUNC, tag) >= 0 && token.spaced || tag === '?' && i > 0 && !tokens[i - 1].spaced) && (indexOf.call(IMPLICIT_CALL, nextTag) >= 0 || indexOf.call(IMPLICIT_UNSPACED_CALL, nextTag) >= 0 && !((ref = tokens[i + 1]) != null ? ref.spaced : void 0) && !((ref1 = tokens[i + 1]) != null ? ref1.newLine : void 0))) {\n          if (tag === '?') {\n            tag = token[0] = 'FUNC_EXIST';\n          }\n          startImplicitCall(i + 1);\n          return forward(2);\n        }\n        if (indexOf.call(IMPLICIT_FUNC, tag) >= 0 && this.indexOfTag(i + 1, 'INDENT') > -1 && this.looksObjectish(i + 2) && !this.findTagsBackwards(i, ['CLASS', 'EXTENDS', 'IF', 'CATCH', 'SWITCH', 'LEADING_WHEN', 'FOR', 'WHILE', 'UNTIL'])) {\n          startImplicitCall(i + 1);\n          stack.push(['INDENT', i + 2]);\n          return forward(3);\n        }\n        if (tag === ':') {\n          s = (function() {\n            var ref2;\n            switch (false) {\n              case ref2 = this.tag(i - 1), indexOf.call(EXPRESSION_END, ref2) < 0:\n                return start[1];\n              case this.tag(i - 2) !== '@':\n                return i - 2;\n              default:\n                return i - 1;\n            }\n          }).call(this);\n          while (this.tag(s - 2) === 'HERECOMMENT') {\n            s -= 2;\n          }\n          this.insideForDeclaration = nextTag === 'FOR';\n          startsLine = s === 0 || (ref2 = this.tag(s - 1), indexOf.call(LINEBREAKS, ref2) >= 0) || tokens[s - 1].newLine;\n          if (stackTop()) {\n            ref3 = stackTop(), stackTag = ref3[0], stackIdx = ref3[1];\n            if ((stackTag === '{' || stackTag === 'INDENT' && this.tag(stackIdx - 1) === '{') && (startsLine || this.tag(s - 1) === ',' || this.tag(s - 1) === '{')) {\n              return forward(1);\n            }\n          }\n          startImplicitObject(s, !!startsLine);\n          return forward(2);\n        }\n        if (indexOf.call(LINEBREAKS, tag) >= 0) {\n          for (k = stack.length - 1; k >= 0; k += -1) {\n            stackItem = stack[k];\n            if (!isImplicit(stackItem)) {\n              break;\n            }\n            if (isImplicitObject(stackItem)) {\n              stackItem[2].sameLine = false;\n            }\n          }\n        }\n        newLine = prevTag === 'OUTDENT' || prevToken.newLine;\n        if (indexOf.call(IMPLICIT_END, tag) >= 0 || indexOf.call(CALL_CLOSERS, tag) >= 0 && newLine) {\n          while (inImplicit()) {\n            ref4 = stackTop(), stackTag = ref4[0], stackIdx = ref4[1], (ref5 = ref4[2], sameLine = ref5.sameLine, startsLine = ref5.startsLine);\n            if (inImplicitCall() && prevTag !== ',') {\n              endImplicitCall();\n            } else if (inImplicitObject() && !this.insideForDeclaration && sameLine && tag !== 'TERMINATOR' && prevTag !== ':') {\n              endImplicitObject();\n            } else if (inImplicitObject() && tag === 'TERMINATOR' && prevTag !== ',' && !(startsLine && this.looksObjectish(i + 1))) {\n              if (nextTag === 'HERECOMMENT') {\n                return forward(1);\n              }\n              endImplicitObject();\n            } else {\n              break;\n            }\n          }\n        }\n        if (tag === ',' && !this.looksObjectish(i + 1) && inImplicitObject() && !this.insideForDeclaration && (nextTag !== 'TERMINATOR' || !this.looksObjectish(i + 2))) {\n          offset = nextTag === 'OUTDENT' ? 1 : 0;\n          while (inImplicitObject()) {\n            endImplicitObject(i + offset);\n          }\n        }\n        return forward(1);\n      });\n    };\n\n    Rewriter.prototype.addLocationDataToGeneratedTokens = function() {\n      return this.scanTokens(function(token, i, tokens) {\n        var column, line, nextLocation, prevLocation, ref, ref1;\n        if (token[2]) {\n          return 1;\n        }\n        if (!(token.generated || token.explicit)) {\n          return 1;\n        }\n        if (token[0] === '{' && (nextLocation = (ref = tokens[i + 1]) != null ? ref[2] : void 0)) {\n          line = nextLocation.first_line, column = nextLocation.first_column;\n        } else if (prevLocation = (ref1 = tokens[i - 1]) != null ? ref1[2] : void 0) {\n          line = prevLocation.last_line, column = prevLocation.last_column;\n        } else {\n          line = column = 0;\n        }\n        token[2] = {\n          first_line: line,\n          first_column: column,\n          last_line: line,\n          last_column: column\n        };\n        return 1;\n      });\n    };\n\n    Rewriter.prototype.fixOutdentLocationData = function() {\n      return this.scanTokens(function(token, i, tokens) {\n        var prevLocationData;\n        if (!(token[0] === 'OUTDENT' || (token.generated && token[0] === 'CALL_END') || (token.generated && token[0] === '}'))) {\n          return 1;\n        }\n        prevLocationData = tokens[i - 1][2];\n        token[2] = {\n          first_line: prevLocationData.last_line,\n          first_column: prevLocationData.last_column,\n          last_line: prevLocationData.last_line,\n          last_column: prevLocationData.last_column\n        };\n        return 1;\n      });\n    };\n\n    Rewriter.prototype.normalizeLines = function() {\n      var action, condition, indent, outdent, starter;\n      starter = indent = outdent = null;\n      condition = function(token, i) {\n        var ref, ref1, ref2, ref3;\n        return token[1] !== ';' && (ref = token[0], indexOf.call(SINGLE_CLOSERS, ref) >= 0) && !(token[0] === 'TERMINATOR' && (ref1 = this.tag(i + 1), indexOf.call(EXPRESSION_CLOSE, ref1) >= 0)) && !(token[0] === 'ELSE' && starter !== 'THEN') && !(((ref2 = token[0]) === 'CATCH' || ref2 === 'FINALLY') && (starter === '->' || starter === '=>')) || (ref3 = token[0], indexOf.call(CALL_CLOSERS, ref3) >= 0) && (this.tokens[i - 1].newLine || this.tokens[i - 1][0] === 'OUTDENT');\n      };\n      action = function(token, i) {\n        return this.tokens.splice((this.tag(i - 1) === ',' ? i - 1 : i), 0, outdent);\n      };\n      return this.scanTokens(function(token, i, tokens) {\n        var j, k, ref, ref1, ref2, tag;\n        tag = token[0];\n        if (tag === 'TERMINATOR') {\n          if (this.tag(i + 1) === 'ELSE' && this.tag(i - 1) !== 'OUTDENT') {\n            tokens.splice.apply(tokens, [i, 1].concat(slice.call(this.indentation())));\n            return 1;\n          }\n          if (ref = this.tag(i + 1), indexOf.call(EXPRESSION_CLOSE, ref) >= 0) {\n            tokens.splice(i, 1);\n            return 0;\n          }\n        }\n        if (tag === 'CATCH') {\n          for (j = k = 1; k <= 2; j = ++k) {\n            if (!((ref1 = this.tag(i + j)) === 'OUTDENT' || ref1 === 'TERMINATOR' || ref1 === 'FINALLY')) {\n              continue;\n            }\n            tokens.splice.apply(tokens, [i + j, 0].concat(slice.call(this.indentation())));\n            return 2 + j;\n          }\n        }\n        if (indexOf.call(SINGLE_LINERS, tag) >= 0 && this.tag(i + 1) !== 'INDENT' && !(tag === 'ELSE' && this.tag(i + 1) === 'IF')) {\n          starter = tag;\n          ref2 = this.indentation(tokens[i]), indent = ref2[0], outdent = ref2[1];\n          if (starter === 'THEN') {\n            indent.fromThen = true;\n          }\n          tokens.splice(i + 1, 0, indent);\n          this.detectEnd(i + 2, condition, action);\n          if (tag === 'THEN') {\n            tokens.splice(i, 1);\n          }\n          return 1;\n        }\n        return 1;\n      });\n    };\n\n    Rewriter.prototype.tagPostfixConditionals = function() {\n      var action, condition, original;\n      original = null;\n      condition = function(token, i) {\n        var prevTag, tag;\n        tag = token[0];\n        prevTag = this.tokens[i - 1][0];\n        return tag === 'TERMINATOR' || (tag === 'INDENT' && indexOf.call(SINGLE_LINERS, prevTag) < 0);\n      };\n      action = function(token, i) {\n        if (token[0] !== 'INDENT' || (token.generated && !token.fromThen)) {\n          return original[0] = 'POST_' + original[0];\n        }\n      };\n      return this.scanTokens(function(token, i) {\n        if (token[0] !== 'IF') {\n          return 1;\n        }\n        original = token;\n        this.detectEnd(i + 1, condition, action);\n        return 1;\n      });\n    };\n\n    Rewriter.prototype.indentation = function(origin) {\n      var indent, outdent;\n      indent = ['INDENT', 2];\n      outdent = ['OUTDENT', 2];\n      if (origin) {\n        indent.generated = outdent.generated = true;\n        indent.origin = outdent.origin = origin;\n      } else {\n        indent.explicit = outdent.explicit = true;\n      }\n      return [indent, outdent];\n    };\n\n    Rewriter.prototype.generate = generate;\n\n    Rewriter.prototype.tag = function(i) {\n      var ref;\n      return (ref = this.tokens[i]) != null ? ref[0] : void 0;\n    };\n\n    return Rewriter;\n\n  })();\n\n  BALANCED_PAIRS = [['(', ')'], ['[', ']'], ['{', '}'], ['INDENT', 'OUTDENT'], ['CALL_START', 'CALL_END'], ['PARAM_START', 'PARAM_END'], ['INDEX_START', 'INDEX_END'], ['STRING_START', 'STRING_END'], ['REGEX_START', 'REGEX_END']];\n\n  exports.INVERSES = INVERSES = {};\n\n  EXPRESSION_START = [];\n\n  EXPRESSION_END = [];\n\n  for (k = 0, len = BALANCED_PAIRS.length; k < len; k++) {\n    ref = BALANCED_PAIRS[k], left = ref[0], rite = ref[1];\n    EXPRESSION_START.push(INVERSES[rite] = left);\n    EXPRESSION_END.push(INVERSES[left] = rite);\n  }\n\n  EXPRESSION_CLOSE = ['CATCH', 'THEN', 'ELSE', 'FINALLY'].concat(EXPRESSION_END);\n\n  IMPLICIT_FUNC = ['IDENTIFIER', 'PROPERTY', 'SUPER', ')', 'CALL_END', ']', 'INDEX_END', '@', 'THIS'];\n\n  IMPLICIT_CALL = ['IDENTIFIER', 'PROPERTY', 'NUMBER', 'INFINITY', 'NAN', 'STRING', 'STRING_START', 'REGEX', 'REGEX_START', 'JS', 'NEW', 'PARAM_START', 'CLASS', 'IF', 'TRY', 'SWITCH', 'THIS', 'UNDEFINED', 'NULL', 'BOOL', 'UNARY', 'YIELD', 'UNARY_MATH', 'SUPER', 'THROW', '@', '->', '=>', '[', '(', '{', '--', '++'];\n\n  IMPLICIT_UNSPACED_CALL = ['+', '-'];\n\n  IMPLICIT_END = ['POST_IF', 'FOR', 'WHILE', 'UNTIL', 'WHEN', 'BY', 'LOOP', 'TERMINATOR'];\n\n  SINGLE_LINERS = ['ELSE', '->', '=>', 'TRY', 'FINALLY', 'THEN'];\n\n  SINGLE_CLOSERS = ['TERMINATOR', 'CATCH', 'FINALLY', 'ELSE', 'OUTDENT', 'LEADING_WHEN'];\n\n  LINEBREAKS = ['TERMINATOR', 'INDENT', 'OUTDENT'];\n\n  CALL_CLOSERS = ['.', '?.', '::', '?::'];\n\n}).call(this);\n"]},"metadata":{},"sourceType":"script"}