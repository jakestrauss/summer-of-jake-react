{"ast":null,"code":"// Generated by CoffeeScript 1.12.7\n(function () {\n  var BOM,\n      BOOL,\n      CALLABLE,\n      CODE,\n      COFFEE_ALIASES,\n      COFFEE_ALIAS_MAP,\n      COFFEE_KEYWORDS,\n      COMMENT,\n      COMPARE,\n      COMPOUND_ASSIGN,\n      HERECOMMENT_ILLEGAL,\n      HEREDOC_DOUBLE,\n      HEREDOC_INDENT,\n      HEREDOC_SINGLE,\n      HEREGEX,\n      HEREGEX_OMIT,\n      HERE_JSTOKEN,\n      IDENTIFIER,\n      INDENTABLE_CLOSERS,\n      INDEXABLE,\n      INVERSES,\n      JSTOKEN,\n      JS_KEYWORDS,\n      LEADING_BLANK_LINE,\n      LINE_BREAK,\n      LINE_CONTINUER,\n      Lexer,\n      MATH,\n      MULTI_DENT,\n      NOT_REGEX,\n      NUMBER,\n      OPERATOR,\n      POSSIBLY_DIVISION,\n      REGEX,\n      REGEX_FLAGS,\n      REGEX_ILLEGAL,\n      REGEX_INVALID_ESCAPE,\n      RELATION,\n      RESERVED,\n      Rewriter,\n      SHIFT,\n      SIMPLE_STRING_OMIT,\n      STRICT_PROSCRIBED,\n      STRING_DOUBLE,\n      STRING_INVALID_ESCAPE,\n      STRING_OMIT,\n      STRING_SINGLE,\n      STRING_START,\n      TRAILING_BLANK_LINE,\n      TRAILING_SPACES,\n      UNARY,\n      UNARY_MATH,\n      UNFINISHED,\n      UNICODE_CODE_POINT_ESCAPE,\n      VALID_FLAGS,\n      WHITESPACE,\n      compact,\n      count,\n      invertLiterate,\n      isForFrom,\n      isUnassignable,\n      key,\n      locationDataToString,\n      ref,\n      ref1,\n      repeat,\n      starts,\n      throwSyntaxError,\n      indexOf = [].indexOf || function (item) {\n    for (var i = 0, l = this.length; i < l; i++) {\n      if (i in this && this[i] === item) return i;\n    }\n\n    return -1;\n  },\n      slice = [].slice;\n\n  ref = require('./rewriter'), Rewriter = ref.Rewriter, INVERSES = ref.INVERSES;\n  ref1 = require('./helpers'), count = ref1.count, starts = ref1.starts, compact = ref1.compact, repeat = ref1.repeat, invertLiterate = ref1.invertLiterate, locationDataToString = ref1.locationDataToString, throwSyntaxError = ref1.throwSyntaxError;\n\n  exports.Lexer = Lexer = function () {\n    function Lexer() {}\n\n    Lexer.prototype.tokenize = function (code, opts) {\n      var consumed, end, i, ref2;\n\n      if (opts == null) {\n        opts = {};\n      }\n\n      this.literate = opts.literate;\n      this.indent = 0;\n      this.baseIndent = 0;\n      this.indebt = 0;\n      this.outdebt = 0;\n      this.indents = [];\n      this.ends = [];\n      this.tokens = [];\n      this.seenFor = false;\n      this.seenImport = false;\n      this.seenExport = false;\n      this.importSpecifierList = false;\n      this.exportSpecifierList = false;\n      this.chunkLine = opts.line || 0;\n      this.chunkColumn = opts.column || 0;\n      code = this.clean(code);\n      i = 0;\n\n      while (this.chunk = code.slice(i)) {\n        consumed = this.identifierToken() || this.commentToken() || this.whitespaceToken() || this.lineToken() || this.stringToken() || this.numberToken() || this.regexToken() || this.jsToken() || this.literalToken();\n        ref2 = this.getLineAndColumnFromChunk(consumed), this.chunkLine = ref2[0], this.chunkColumn = ref2[1];\n        i += consumed;\n\n        if (opts.untilBalanced && this.ends.length === 0) {\n          return {\n            tokens: this.tokens,\n            index: i\n          };\n        }\n      }\n\n      this.closeIndentation();\n\n      if (end = this.ends.pop()) {\n        this.error(\"missing \" + end.tag, end.origin[2]);\n      }\n\n      if (opts.rewrite === false) {\n        return this.tokens;\n      }\n\n      return new Rewriter().rewrite(this.tokens);\n    };\n\n    Lexer.prototype.clean = function (code) {\n      if (code.charCodeAt(0) === BOM) {\n        code = code.slice(1);\n      }\n\n      code = code.replace(/\\r/g, '').replace(TRAILING_SPACES, '');\n\n      if (WHITESPACE.test(code)) {\n        code = \"\\n\" + code;\n        this.chunkLine--;\n      }\n\n      if (this.literate) {\n        code = invertLiterate(code);\n      }\n\n      return code;\n    };\n\n    Lexer.prototype.identifierToken = function () {\n      var alias, colon, colonOffset, id, idLength, input, match, poppedToken, prev, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, tag, tagToken;\n\n      if (!(match = IDENTIFIER.exec(this.chunk))) {\n        return 0;\n      }\n\n      input = match[0], id = match[1], colon = match[2];\n      idLength = id.length;\n      poppedToken = void 0;\n\n      if (id === 'own' && this.tag() === 'FOR') {\n        this.token('OWN', id);\n        return id.length;\n      }\n\n      if (id === 'from' && this.tag() === 'YIELD') {\n        this.token('FROM', id);\n        return id.length;\n      }\n\n      if (id === 'as' && this.seenImport) {\n        if (this.value() === '*') {\n          this.tokens[this.tokens.length - 1][0] = 'IMPORT_ALL';\n        } else if (ref2 = this.value(), indexOf.call(COFFEE_KEYWORDS, ref2) >= 0) {\n          this.tokens[this.tokens.length - 1][0] = 'IDENTIFIER';\n        }\n\n        if ((ref3 = this.tag()) === 'DEFAULT' || ref3 === 'IMPORT_ALL' || ref3 === 'IDENTIFIER') {\n          this.token('AS', id);\n          return id.length;\n        }\n      }\n\n      if (id === 'as' && this.seenExport && ((ref4 = this.tag()) === 'IDENTIFIER' || ref4 === 'DEFAULT')) {\n        this.token('AS', id);\n        return id.length;\n      }\n\n      if (id === 'default' && this.seenExport && ((ref5 = this.tag()) === 'EXPORT' || ref5 === 'AS')) {\n        this.token('DEFAULT', id);\n        return id.length;\n      }\n\n      ref6 = this.tokens, prev = ref6[ref6.length - 1];\n      tag = colon || prev != null && ((ref7 = prev[0]) === '.' || ref7 === '?.' || ref7 === '::' || ref7 === '?::' || !prev.spaced && prev[0] === '@') ? 'PROPERTY' : 'IDENTIFIER';\n\n      if (tag === 'IDENTIFIER' && (indexOf.call(JS_KEYWORDS, id) >= 0 || indexOf.call(COFFEE_KEYWORDS, id) >= 0) && !(this.exportSpecifierList && indexOf.call(COFFEE_KEYWORDS, id) >= 0)) {\n        tag = id.toUpperCase();\n\n        if (tag === 'WHEN' && (ref8 = this.tag(), indexOf.call(LINE_BREAK, ref8) >= 0)) {\n          tag = 'LEADING_WHEN';\n        } else if (tag === 'FOR') {\n          this.seenFor = true;\n        } else if (tag === 'UNLESS') {\n          tag = 'IF';\n        } else if (tag === 'IMPORT') {\n          this.seenImport = true;\n        } else if (tag === 'EXPORT') {\n          this.seenExport = true;\n        } else if (indexOf.call(UNARY, tag) >= 0) {\n          tag = 'UNARY';\n        } else if (indexOf.call(RELATION, tag) >= 0) {\n          if (tag !== 'INSTANCEOF' && this.seenFor) {\n            tag = 'FOR' + tag;\n            this.seenFor = false;\n          } else {\n            tag = 'RELATION';\n\n            if (this.value() === '!') {\n              poppedToken = this.tokens.pop();\n              id = '!' + id;\n            }\n          }\n        }\n      } else if (tag === 'IDENTIFIER' && this.seenFor && id === 'from' && isForFrom(prev)) {\n        tag = 'FORFROM';\n        this.seenFor = false;\n      }\n\n      if (tag === 'IDENTIFIER' && indexOf.call(RESERVED, id) >= 0) {\n        this.error(\"reserved word '\" + id + \"'\", {\n          length: id.length\n        });\n      }\n\n      if (tag !== 'PROPERTY') {\n        if (indexOf.call(COFFEE_ALIASES, id) >= 0) {\n          alias = id;\n          id = COFFEE_ALIAS_MAP[id];\n        }\n\n        tag = function () {\n          switch (id) {\n            case '!':\n              return 'UNARY';\n\n            case '==':\n            case '!=':\n              return 'COMPARE';\n\n            case 'true':\n            case 'false':\n              return 'BOOL';\n\n            case 'break':\n            case 'continue':\n            case 'debugger':\n              return 'STATEMENT';\n\n            case '&&':\n            case '||':\n              return id;\n\n            default:\n              return tag;\n          }\n        }();\n      }\n\n      tagToken = this.token(tag, id, 0, idLength);\n\n      if (alias) {\n        tagToken.origin = [tag, alias, tagToken[2]];\n      }\n\n      if (poppedToken) {\n        ref9 = [poppedToken[2].first_line, poppedToken[2].first_column], tagToken[2].first_line = ref9[0], tagToken[2].first_column = ref9[1];\n      }\n\n      if (colon) {\n        colonOffset = input.lastIndexOf(':');\n        this.token(':', ':', colonOffset, colon.length);\n      }\n\n      return input.length;\n    };\n\n    Lexer.prototype.numberToken = function () {\n      var base, lexedLength, match, number, numberValue, ref2, tag;\n\n      if (!(match = NUMBER.exec(this.chunk))) {\n        return 0;\n      }\n\n      number = match[0];\n      lexedLength = number.length;\n\n      switch (false) {\n        case !/^0[BOX]/.test(number):\n          this.error(\"radix prefix in '\" + number + \"' must be lowercase\", {\n            offset: 1\n          });\n          break;\n\n        case !/^(?!0x).*E/.test(number):\n          this.error(\"exponential notation in '\" + number + \"' must be indicated with a lowercase 'e'\", {\n            offset: number.indexOf('E')\n          });\n          break;\n\n        case !/^0\\d*[89]/.test(number):\n          this.error(\"decimal literal '\" + number + \"' must not be prefixed with '0'\", {\n            length: lexedLength\n          });\n          break;\n\n        case !/^0\\d+/.test(number):\n          this.error(\"octal literal '\" + number + \"' must be prefixed with '0o'\", {\n            length: lexedLength\n          });\n      }\n\n      base = function () {\n        switch (number.charAt(1)) {\n          case 'b':\n            return 2;\n\n          case 'o':\n            return 8;\n\n          case 'x':\n            return 16;\n\n          default:\n            return null;\n        }\n      }();\n\n      numberValue = base != null ? parseInt(number.slice(2), base) : parseFloat(number);\n\n      if ((ref2 = number.charAt(1)) === 'b' || ref2 === 'o') {\n        number = \"0x\" + numberValue.toString(16);\n      }\n\n      tag = numberValue === 2e308 ? 'INFINITY' : 'NUMBER';\n      this.token(tag, number, 0, lexedLength);\n      return lexedLength;\n    };\n\n    Lexer.prototype.stringToken = function () {\n      var $, attempt, delimiter, doc, end, heredoc, i, indent, indentRegex, match, quote, ref2, ref3, regex, token, tokens;\n      quote = (STRING_START.exec(this.chunk) || [])[0];\n\n      if (!quote) {\n        return 0;\n      }\n\n      if (this.tokens.length && this.value() === 'from' && (this.seenImport || this.seenExport)) {\n        this.tokens[this.tokens.length - 1][0] = 'FROM';\n      }\n\n      regex = function () {\n        switch (quote) {\n          case \"'\":\n            return STRING_SINGLE;\n\n          case '\"':\n            return STRING_DOUBLE;\n\n          case \"'''\":\n            return HEREDOC_SINGLE;\n\n          case '\"\"\"':\n            return HEREDOC_DOUBLE;\n        }\n      }();\n\n      heredoc = quote.length === 3;\n      ref2 = this.matchWithInterpolations(regex, quote), tokens = ref2.tokens, end = ref2.index;\n      $ = tokens.length - 1;\n      delimiter = quote.charAt(0);\n\n      if (heredoc) {\n        indent = null;\n\n        doc = function () {\n          var j, len, results;\n          results = [];\n\n          for (i = j = 0, len = tokens.length; j < len; i = ++j) {\n            token = tokens[i];\n\n            if (token[0] === 'NEOSTRING') {\n              results.push(token[1]);\n            }\n          }\n\n          return results;\n        }().join('#{}');\n\n        while (match = HEREDOC_INDENT.exec(doc)) {\n          attempt = match[1];\n\n          if (indent === null || 0 < (ref3 = attempt.length) && ref3 < indent.length) {\n            indent = attempt;\n          }\n        }\n\n        if (indent) {\n          indentRegex = RegExp(\"\\\\n\" + indent, \"g\");\n        }\n\n        this.mergeInterpolationTokens(tokens, {\n          delimiter: delimiter\n        }, function (_this) {\n          return function (value, i) {\n            value = _this.formatString(value, {\n              delimiter: quote\n            });\n\n            if (indentRegex) {\n              value = value.replace(indentRegex, '\\n');\n            }\n\n            if (i === 0) {\n              value = value.replace(LEADING_BLANK_LINE, '');\n            }\n\n            if (i === $) {\n              value = value.replace(TRAILING_BLANK_LINE, '');\n            }\n\n            return value;\n          };\n        }(this));\n      } else {\n        this.mergeInterpolationTokens(tokens, {\n          delimiter: delimiter\n        }, function (_this) {\n          return function (value, i) {\n            value = _this.formatString(value, {\n              delimiter: quote\n            });\n            value = value.replace(SIMPLE_STRING_OMIT, function (match, offset) {\n              if (i === 0 && offset === 0 || i === $ && offset + match.length === value.length) {\n                return '';\n              } else {\n                return ' ';\n              }\n            });\n            return value;\n          };\n        }(this));\n      }\n\n      return end;\n    };\n\n    Lexer.prototype.commentToken = function () {\n      var comment, here, match;\n\n      if (!(match = this.chunk.match(COMMENT))) {\n        return 0;\n      }\n\n      comment = match[0], here = match[1];\n\n      if (here) {\n        if (match = HERECOMMENT_ILLEGAL.exec(comment)) {\n          this.error(\"block comments cannot contain \" + match[0], {\n            offset: match.index,\n            length: match[0].length\n          });\n        }\n\n        if (here.indexOf('\\n') >= 0) {\n          here = here.replace(RegExp(\"\\\\n\" + repeat(' ', this.indent), \"g\"), '\\n');\n        }\n\n        this.token('HERECOMMENT', here, 0, comment.length);\n      }\n\n      return comment.length;\n    };\n\n    Lexer.prototype.jsToken = function () {\n      var match, script;\n\n      if (!(this.chunk.charAt(0) === '`' && (match = HERE_JSTOKEN.exec(this.chunk) || JSTOKEN.exec(this.chunk)))) {\n        return 0;\n      }\n\n      script = match[1].replace(/\\\\+(`|$)/g, function (string) {\n        return string.slice(-Math.ceil(string.length / 2));\n      });\n      this.token('JS', script, 0, match[0].length);\n      return match[0].length;\n    };\n\n    Lexer.prototype.regexToken = function () {\n      var body, closed, end, flags, index, match, origin, prev, ref2, ref3, ref4, regex, tokens;\n\n      switch (false) {\n        case !(match = REGEX_ILLEGAL.exec(this.chunk)):\n          this.error(\"regular expressions cannot begin with \" + match[2], {\n            offset: match.index + match[1].length\n          });\n          break;\n\n        case !(match = this.matchWithInterpolations(HEREGEX, '///')):\n          tokens = match.tokens, index = match.index;\n          break;\n\n        case !(match = REGEX.exec(this.chunk)):\n          regex = match[0], body = match[1], closed = match[2];\n          this.validateEscapes(body, {\n            isRegex: true,\n            offsetInChunk: 1\n          });\n          body = this.formatRegex(body, {\n            delimiter: '/'\n          });\n          index = regex.length;\n          ref2 = this.tokens, prev = ref2[ref2.length - 1];\n\n          if (prev) {\n            if (prev.spaced && (ref3 = prev[0], indexOf.call(CALLABLE, ref3) >= 0)) {\n              if (!closed || POSSIBLY_DIVISION.test(regex)) {\n                return 0;\n              }\n            } else if (ref4 = prev[0], indexOf.call(NOT_REGEX, ref4) >= 0) {\n              return 0;\n            }\n          }\n\n          if (!closed) {\n            this.error('missing / (unclosed regex)');\n          }\n\n          break;\n\n        default:\n          return 0;\n      }\n\n      flags = REGEX_FLAGS.exec(this.chunk.slice(index))[0];\n      end = index + flags.length;\n      origin = this.makeToken('REGEX', null, 0, end);\n\n      switch (false) {\n        case !!VALID_FLAGS.test(flags):\n          this.error(\"invalid regular expression flags \" + flags, {\n            offset: index,\n            length: flags.length\n          });\n          break;\n\n        case !(regex || tokens.length === 1):\n          if (body == null) {\n            body = this.formatHeregex(tokens[0][1]);\n          }\n\n          this.token('REGEX', \"\" + this.makeDelimitedLiteral(body, {\n            delimiter: '/'\n          }) + flags, 0, end, origin);\n          break;\n\n        default:\n          this.token('REGEX_START', '(', 0, 0, origin);\n          this.token('IDENTIFIER', 'RegExp', 0, 0);\n          this.token('CALL_START', '(', 0, 0);\n          this.mergeInterpolationTokens(tokens, {\n            delimiter: '\"',\n            double: true\n          }, this.formatHeregex);\n\n          if (flags) {\n            this.token(',', ',', index - 1, 0);\n            this.token('STRING', '\"' + flags + '\"', index - 1, flags.length);\n          }\n\n          this.token(')', ')', end - 1, 0);\n          this.token('REGEX_END', ')', end - 1, 0);\n      }\n\n      return end;\n    };\n\n    Lexer.prototype.lineToken = function () {\n      var diff, indent, match, noNewlines, size;\n\n      if (!(match = MULTI_DENT.exec(this.chunk))) {\n        return 0;\n      }\n\n      indent = match[0];\n      this.seenFor = false;\n\n      if (!this.importSpecifierList) {\n        this.seenImport = false;\n      }\n\n      if (!this.exportSpecifierList) {\n        this.seenExport = false;\n      }\n\n      size = indent.length - 1 - indent.lastIndexOf('\\n');\n      noNewlines = this.unfinished();\n\n      if (size - this.indebt === this.indent) {\n        if (noNewlines) {\n          this.suppressNewlines();\n        } else {\n          this.newlineToken(0);\n        }\n\n        return indent.length;\n      }\n\n      if (size > this.indent) {\n        if (noNewlines) {\n          this.indebt = size - this.indent;\n          this.suppressNewlines();\n          return indent.length;\n        }\n\n        if (!this.tokens.length) {\n          this.baseIndent = this.indent = size;\n          return indent.length;\n        }\n\n        diff = size - this.indent + this.outdebt;\n        this.token('INDENT', diff, indent.length - size, size);\n        this.indents.push(diff);\n        this.ends.push({\n          tag: 'OUTDENT'\n        });\n        this.outdebt = this.indebt = 0;\n        this.indent = size;\n      } else if (size < this.baseIndent) {\n        this.error('missing indentation', {\n          offset: indent.length\n        });\n      } else {\n        this.indebt = 0;\n        this.outdentToken(this.indent - size, noNewlines, indent.length);\n      }\n\n      return indent.length;\n    };\n\n    Lexer.prototype.outdentToken = function (moveOut, noNewlines, outdentLength) {\n      var decreasedIndent, dent, lastIndent, ref2;\n      decreasedIndent = this.indent - moveOut;\n\n      while (moveOut > 0) {\n        lastIndent = this.indents[this.indents.length - 1];\n\n        if (!lastIndent) {\n          moveOut = 0;\n        } else if (lastIndent === this.outdebt) {\n          moveOut -= this.outdebt;\n          this.outdebt = 0;\n        } else if (lastIndent < this.outdebt) {\n          this.outdebt -= lastIndent;\n          moveOut -= lastIndent;\n        } else {\n          dent = this.indents.pop() + this.outdebt;\n\n          if (outdentLength && (ref2 = this.chunk[outdentLength], indexOf.call(INDENTABLE_CLOSERS, ref2) >= 0)) {\n            decreasedIndent -= dent - moveOut;\n            moveOut = dent;\n          }\n\n          this.outdebt = 0;\n          this.pair('OUTDENT');\n          this.token('OUTDENT', moveOut, 0, outdentLength);\n          moveOut -= dent;\n        }\n      }\n\n      if (dent) {\n        this.outdebt -= moveOut;\n      }\n\n      while (this.value() === ';') {\n        this.tokens.pop();\n      }\n\n      if (!(this.tag() === 'TERMINATOR' || noNewlines)) {\n        this.token('TERMINATOR', '\\n', outdentLength, 0);\n      }\n\n      this.indent = decreasedIndent;\n      return this;\n    };\n\n    Lexer.prototype.whitespaceToken = function () {\n      var match, nline, prev, ref2;\n\n      if (!((match = WHITESPACE.exec(this.chunk)) || (nline = this.chunk.charAt(0) === '\\n'))) {\n        return 0;\n      }\n\n      ref2 = this.tokens, prev = ref2[ref2.length - 1];\n\n      if (prev) {\n        prev[match ? 'spaced' : 'newLine'] = true;\n      }\n\n      if (match) {\n        return match[0].length;\n      } else {\n        return 0;\n      }\n    };\n\n    Lexer.prototype.newlineToken = function (offset) {\n      while (this.value() === ';') {\n        this.tokens.pop();\n      }\n\n      if (this.tag() !== 'TERMINATOR') {\n        this.token('TERMINATOR', '\\n', offset, 0);\n      }\n\n      return this;\n    };\n\n    Lexer.prototype.suppressNewlines = function () {\n      if (this.value() === '\\\\') {\n        this.tokens.pop();\n      }\n\n      return this;\n    };\n\n    Lexer.prototype.literalToken = function () {\n      var match, message, origin, prev, ref2, ref3, ref4, ref5, ref6, skipToken, tag, token, value;\n\n      if (match = OPERATOR.exec(this.chunk)) {\n        value = match[0];\n\n        if (CODE.test(value)) {\n          this.tagParameters();\n        }\n      } else {\n        value = this.chunk.charAt(0);\n      }\n\n      tag = value;\n      ref2 = this.tokens, prev = ref2[ref2.length - 1];\n\n      if (prev && indexOf.call(['='].concat(slice.call(COMPOUND_ASSIGN)), value) >= 0) {\n        skipToken = false;\n\n        if (value === '=' && ((ref3 = prev[1]) === '||' || ref3 === '&&') && !prev.spaced) {\n          prev[0] = 'COMPOUND_ASSIGN';\n          prev[1] += '=';\n          prev = this.tokens[this.tokens.length - 2];\n          skipToken = true;\n        }\n\n        if (prev && prev[0] !== 'PROPERTY') {\n          origin = (ref4 = prev.origin) != null ? ref4 : prev;\n          message = isUnassignable(prev[1], origin[1]);\n\n          if (message) {\n            this.error(message, origin[2]);\n          }\n        }\n\n        if (skipToken) {\n          return value.length;\n        }\n      }\n\n      if (value === '{' && this.seenImport) {\n        this.importSpecifierList = true;\n      } else if (this.importSpecifierList && value === '}') {\n        this.importSpecifierList = false;\n      } else if (value === '{' && (prev != null ? prev[0] : void 0) === 'EXPORT') {\n        this.exportSpecifierList = true;\n      } else if (this.exportSpecifierList && value === '}') {\n        this.exportSpecifierList = false;\n      }\n\n      if (value === ';') {\n        this.seenFor = this.seenImport = this.seenExport = false;\n        tag = 'TERMINATOR';\n      } else if (value === '*' && prev[0] === 'EXPORT') {\n        tag = 'EXPORT_ALL';\n      } else if (indexOf.call(MATH, value) >= 0) {\n        tag = 'MATH';\n      } else if (indexOf.call(COMPARE, value) >= 0) {\n        tag = 'COMPARE';\n      } else if (indexOf.call(COMPOUND_ASSIGN, value) >= 0) {\n        tag = 'COMPOUND_ASSIGN';\n      } else if (indexOf.call(UNARY, value) >= 0) {\n        tag = 'UNARY';\n      } else if (indexOf.call(UNARY_MATH, value) >= 0) {\n        tag = 'UNARY_MATH';\n      } else if (indexOf.call(SHIFT, value) >= 0) {\n        tag = 'SHIFT';\n      } else if (value === '?' && (prev != null ? prev.spaced : void 0)) {\n        tag = 'BIN?';\n      } else if (prev && !prev.spaced) {\n        if (value === '(' && (ref5 = prev[0], indexOf.call(CALLABLE, ref5) >= 0)) {\n          if (prev[0] === '?') {\n            prev[0] = 'FUNC_EXIST';\n          }\n\n          tag = 'CALL_START';\n        } else if (value === '[' && (ref6 = prev[0], indexOf.call(INDEXABLE, ref6) >= 0)) {\n          tag = 'INDEX_START';\n\n          switch (prev[0]) {\n            case '?':\n              prev[0] = 'INDEX_SOAK';\n          }\n        }\n      }\n\n      token = this.makeToken(tag, value);\n\n      switch (value) {\n        case '(':\n        case '{':\n        case '[':\n          this.ends.push({\n            tag: INVERSES[value],\n            origin: token\n          });\n          break;\n\n        case ')':\n        case '}':\n        case ']':\n          this.pair(value);\n      }\n\n      this.tokens.push(token);\n      return value.length;\n    };\n\n    Lexer.prototype.tagParameters = function () {\n      var i, stack, tok, tokens;\n\n      if (this.tag() !== ')') {\n        return this;\n      }\n\n      stack = [];\n      tokens = this.tokens;\n      i = tokens.length;\n      tokens[--i][0] = 'PARAM_END';\n\n      while (tok = tokens[--i]) {\n        switch (tok[0]) {\n          case ')':\n            stack.push(tok);\n            break;\n\n          case '(':\n          case 'CALL_START':\n            if (stack.length) {\n              stack.pop();\n            } else if (tok[0] === '(') {\n              tok[0] = 'PARAM_START';\n              return this;\n            } else {\n              return this;\n            }\n\n        }\n      }\n\n      return this;\n    };\n\n    Lexer.prototype.closeIndentation = function () {\n      return this.outdentToken(this.indent);\n    };\n\n    Lexer.prototype.matchWithInterpolations = function (regex, delimiter) {\n      var close, column, firstToken, index, lastToken, line, nested, offsetInChunk, open, ref2, ref3, ref4, str, strPart, tokens;\n      tokens = [];\n      offsetInChunk = delimiter.length;\n\n      if (this.chunk.slice(0, offsetInChunk) !== delimiter) {\n        return null;\n      }\n\n      str = this.chunk.slice(offsetInChunk);\n\n      while (true) {\n        strPart = regex.exec(str)[0];\n        this.validateEscapes(strPart, {\n          isRegex: delimiter.charAt(0) === '/',\n          offsetInChunk: offsetInChunk\n        });\n        tokens.push(this.makeToken('NEOSTRING', strPart, offsetInChunk));\n        str = str.slice(strPart.length);\n        offsetInChunk += strPart.length;\n\n        if (str.slice(0, 2) !== '#{') {\n          break;\n        }\n\n        ref2 = this.getLineAndColumnFromChunk(offsetInChunk + 1), line = ref2[0], column = ref2[1];\n        ref3 = new Lexer().tokenize(str.slice(1), {\n          line: line,\n          column: column,\n          untilBalanced: true\n        }), nested = ref3.tokens, index = ref3.index;\n        index += 1;\n        open = nested[0], close = nested[nested.length - 1];\n        open[0] = open[1] = '(';\n        close[0] = close[1] = ')';\n        close.origin = ['', 'end of interpolation', close[2]];\n\n        if (((ref4 = nested[1]) != null ? ref4[0] : void 0) === 'TERMINATOR') {\n          nested.splice(1, 1);\n        }\n\n        tokens.push(['TOKENS', nested]);\n        str = str.slice(index);\n        offsetInChunk += index;\n      }\n\n      if (str.slice(0, delimiter.length) !== delimiter) {\n        this.error(\"missing \" + delimiter, {\n          length: delimiter.length\n        });\n      }\n\n      firstToken = tokens[0], lastToken = tokens[tokens.length - 1];\n      firstToken[2].first_column -= delimiter.length;\n\n      if (lastToken[1].substr(-1) === '\\n') {\n        lastToken[2].last_line += 1;\n        lastToken[2].last_column = delimiter.length - 1;\n      } else {\n        lastToken[2].last_column += delimiter.length;\n      }\n\n      if (lastToken[1].length === 0) {\n        lastToken[2].last_column -= 1;\n      }\n\n      return {\n        tokens: tokens,\n        index: offsetInChunk + delimiter.length\n      };\n    };\n\n    Lexer.prototype.mergeInterpolationTokens = function (tokens, options, fn) {\n      var converted, firstEmptyStringIndex, firstIndex, i, j, lastToken, len, locationToken, lparen, plusToken, ref2, rparen, tag, token, tokensToPush, value;\n\n      if (tokens.length > 1) {\n        lparen = this.token('STRING_START', '(', 0, 0);\n      }\n\n      firstIndex = this.tokens.length;\n\n      for (i = j = 0, len = tokens.length; j < len; i = ++j) {\n        token = tokens[i];\n        tag = token[0], value = token[1];\n\n        switch (tag) {\n          case 'TOKENS':\n            if (value.length === 2) {\n              continue;\n            }\n\n            locationToken = value[0];\n            tokensToPush = value;\n            break;\n\n          case 'NEOSTRING':\n            converted = fn.call(this, token[1], i);\n\n            if (converted.length === 0) {\n              if (i === 0) {\n                firstEmptyStringIndex = this.tokens.length;\n              } else {\n                continue;\n              }\n            }\n\n            if (i === 2 && firstEmptyStringIndex != null) {\n              this.tokens.splice(firstEmptyStringIndex, 2);\n            }\n\n            token[0] = 'STRING';\n            token[1] = this.makeDelimitedLiteral(converted, options);\n            locationToken = token;\n            tokensToPush = [token];\n        }\n\n        if (this.tokens.length > firstIndex) {\n          plusToken = this.token('+', '+');\n          plusToken[2] = {\n            first_line: locationToken[2].first_line,\n            first_column: locationToken[2].first_column,\n            last_line: locationToken[2].first_line,\n            last_column: locationToken[2].first_column\n          };\n        }\n\n        (ref2 = this.tokens).push.apply(ref2, tokensToPush);\n      }\n\n      if (lparen) {\n        lastToken = tokens[tokens.length - 1];\n        lparen.origin = ['STRING', null, {\n          first_line: lparen[2].first_line,\n          first_column: lparen[2].first_column,\n          last_line: lastToken[2].last_line,\n          last_column: lastToken[2].last_column\n        }];\n        rparen = this.token('STRING_END', ')');\n        return rparen[2] = {\n          first_line: lastToken[2].last_line,\n          first_column: lastToken[2].last_column,\n          last_line: lastToken[2].last_line,\n          last_column: lastToken[2].last_column\n        };\n      }\n    };\n\n    Lexer.prototype.pair = function (tag) {\n      var lastIndent, prev, ref2, ref3, wanted;\n      ref2 = this.ends, prev = ref2[ref2.length - 1];\n\n      if (tag !== (wanted = prev != null ? prev.tag : void 0)) {\n        if ('OUTDENT' !== wanted) {\n          this.error(\"unmatched \" + tag);\n        }\n\n        ref3 = this.indents, lastIndent = ref3[ref3.length - 1];\n        this.outdentToken(lastIndent, true);\n        return this.pair(tag);\n      }\n\n      return this.ends.pop();\n    };\n\n    Lexer.prototype.getLineAndColumnFromChunk = function (offset) {\n      var column, lastLine, lineCount, ref2, string;\n\n      if (offset === 0) {\n        return [this.chunkLine, this.chunkColumn];\n      }\n\n      if (offset >= this.chunk.length) {\n        string = this.chunk;\n      } else {\n        string = this.chunk.slice(0, +(offset - 1) + 1 || 9e9);\n      }\n\n      lineCount = count(string, '\\n');\n      column = this.chunkColumn;\n\n      if (lineCount > 0) {\n        ref2 = string.split('\\n'), lastLine = ref2[ref2.length - 1];\n        column = lastLine.length;\n      } else {\n        column += string.length;\n      }\n\n      return [this.chunkLine + lineCount, column];\n    };\n\n    Lexer.prototype.makeToken = function (tag, value, offsetInChunk, length) {\n      var lastCharacter, locationData, ref2, ref3, token;\n\n      if (offsetInChunk == null) {\n        offsetInChunk = 0;\n      }\n\n      if (length == null) {\n        length = value.length;\n      }\n\n      locationData = {};\n      ref2 = this.getLineAndColumnFromChunk(offsetInChunk), locationData.first_line = ref2[0], locationData.first_column = ref2[1];\n      lastCharacter = length > 0 ? length - 1 : 0;\n      ref3 = this.getLineAndColumnFromChunk(offsetInChunk + lastCharacter), locationData.last_line = ref3[0], locationData.last_column = ref3[1];\n      token = [tag, value, locationData];\n      return token;\n    };\n\n    Lexer.prototype.token = function (tag, value, offsetInChunk, length, origin) {\n      var token;\n      token = this.makeToken(tag, value, offsetInChunk, length);\n\n      if (origin) {\n        token.origin = origin;\n      }\n\n      this.tokens.push(token);\n      return token;\n    };\n\n    Lexer.prototype.tag = function () {\n      var ref2, token;\n      ref2 = this.tokens, token = ref2[ref2.length - 1];\n      return token != null ? token[0] : void 0;\n    };\n\n    Lexer.prototype.value = function () {\n      var ref2, token;\n      ref2 = this.tokens, token = ref2[ref2.length - 1];\n      return token != null ? token[1] : void 0;\n    };\n\n    Lexer.prototype.unfinished = function () {\n      var ref2;\n      return LINE_CONTINUER.test(this.chunk) || (ref2 = this.tag(), indexOf.call(UNFINISHED, ref2) >= 0);\n    };\n\n    Lexer.prototype.formatString = function (str, options) {\n      return this.replaceUnicodeCodePointEscapes(str.replace(STRING_OMIT, '$1'), options);\n    };\n\n    Lexer.prototype.formatHeregex = function (str) {\n      return this.formatRegex(str.replace(HEREGEX_OMIT, '$1$2'), {\n        delimiter: '///'\n      });\n    };\n\n    Lexer.prototype.formatRegex = function (str, options) {\n      return this.replaceUnicodeCodePointEscapes(str, options);\n    };\n\n    Lexer.prototype.unicodeCodePointToUnicodeEscapes = function (codePoint) {\n      var high, low, toUnicodeEscape;\n\n      toUnicodeEscape = function (val) {\n        var str;\n        str = val.toString(16);\n        return \"\\\\u\" + repeat('0', 4 - str.length) + str;\n      };\n\n      if (codePoint < 0x10000) {\n        return toUnicodeEscape(codePoint);\n      }\n\n      high = Math.floor((codePoint - 0x10000) / 0x400) + 0xD800;\n      low = (codePoint - 0x10000) % 0x400 + 0xDC00;\n      return \"\" + toUnicodeEscape(high) + toUnicodeEscape(low);\n    };\n\n    Lexer.prototype.replaceUnicodeCodePointEscapes = function (str, options) {\n      return str.replace(UNICODE_CODE_POINT_ESCAPE, function (_this) {\n        return function (match, escapedBackslash, codePointHex, offset) {\n          var codePointDecimal;\n\n          if (escapedBackslash) {\n            return escapedBackslash;\n          }\n\n          codePointDecimal = parseInt(codePointHex, 16);\n\n          if (codePointDecimal > 0x10ffff) {\n            _this.error(\"unicode code point escapes greater than \\\\u{10ffff} are not allowed\", {\n              offset: offset + options.delimiter.length,\n              length: codePointHex.length + 4\n            });\n          }\n\n          return _this.unicodeCodePointToUnicodeEscapes(codePointDecimal);\n        };\n      }(this));\n    };\n\n    Lexer.prototype.validateEscapes = function (str, options) {\n      var before, hex, invalidEscape, invalidEscapeRegex, match, message, octal, ref2, unicode, unicodeCodePoint;\n\n      if (options == null) {\n        options = {};\n      }\n\n      invalidEscapeRegex = options.isRegex ? REGEX_INVALID_ESCAPE : STRING_INVALID_ESCAPE;\n      match = invalidEscapeRegex.exec(str);\n\n      if (!match) {\n        return;\n      }\n\n      match[0], before = match[1], octal = match[2], hex = match[3], unicodeCodePoint = match[4], unicode = match[5];\n      message = octal ? \"octal escape sequences are not allowed\" : \"invalid escape sequence\";\n      invalidEscape = \"\\\\\" + (octal || hex || unicodeCodePoint || unicode);\n      return this.error(message + \" \" + invalidEscape, {\n        offset: ((ref2 = options.offsetInChunk) != null ? ref2 : 0) + match.index + before.length,\n        length: invalidEscape.length\n      });\n    };\n\n    Lexer.prototype.makeDelimitedLiteral = function (body, options) {\n      var regex;\n\n      if (options == null) {\n        options = {};\n      }\n\n      if (body === '' && options.delimiter === '/') {\n        body = '(?:)';\n      }\n\n      regex = RegExp(\"(\\\\\\\\\\\\\\\\)|(\\\\\\\\0(?=[1-7]))|\\\\\\\\?(\" + options.delimiter + \")|\\\\\\\\?(?:(\\\\n)|(\\\\r)|(\\\\u2028)|(\\\\u2029))|(\\\\\\\\.)\", \"g\");\n      body = body.replace(regex, function (match, backslash, nul, delimiter, lf, cr, ls, ps, other) {\n        switch (false) {\n          case !backslash:\n            if (options.double) {\n              return backslash + backslash;\n            } else {\n              return backslash;\n            }\n\n          case !nul:\n            return '\\\\x00';\n\n          case !delimiter:\n            return \"\\\\\" + delimiter;\n\n          case !lf:\n            return '\\\\n';\n\n          case !cr:\n            return '\\\\r';\n\n          case !ls:\n            return '\\\\u2028';\n\n          case !ps:\n            return '\\\\u2029';\n\n          case !other:\n            if (options.double) {\n              return \"\\\\\" + other;\n            } else {\n              return other;\n            }\n\n        }\n      });\n      return \"\" + options.delimiter + body + options.delimiter;\n    };\n\n    Lexer.prototype.error = function (message, options) {\n      var first_column, first_line, location, ref2, ref3, ref4;\n\n      if (options == null) {\n        options = {};\n      }\n\n      location = 'first_line' in options ? options : ((ref3 = this.getLineAndColumnFromChunk((ref2 = options.offset) != null ? ref2 : 0), first_line = ref3[0], first_column = ref3[1], ref3), {\n        first_line: first_line,\n        first_column: first_column,\n        last_column: first_column + ((ref4 = options.length) != null ? ref4 : 1) - 1\n      });\n      return throwSyntaxError(message, location);\n    };\n\n    return Lexer;\n  }();\n\n  isUnassignable = function (name, displayName) {\n    if (displayName == null) {\n      displayName = name;\n    }\n\n    switch (false) {\n      case indexOf.call(slice.call(JS_KEYWORDS).concat(slice.call(COFFEE_KEYWORDS)), name) < 0:\n        return \"keyword '\" + displayName + \"' can't be assigned\";\n\n      case indexOf.call(STRICT_PROSCRIBED, name) < 0:\n        return \"'\" + displayName + \"' can't be assigned\";\n\n      case indexOf.call(RESERVED, name) < 0:\n        return \"reserved word '\" + displayName + \"' can't be assigned\";\n\n      default:\n        return false;\n    }\n  };\n\n  exports.isUnassignable = isUnassignable;\n\n  isForFrom = function (prev) {\n    var ref2;\n\n    if (prev[0] === 'IDENTIFIER') {\n      if (prev[1] === 'from') {\n        prev[1][0] = 'IDENTIFIER';\n        true;\n      }\n\n      return true;\n    } else if (prev[0] === 'FOR') {\n      return false;\n    } else if ((ref2 = prev[1]) === '{' || ref2 === '[' || ref2 === ',' || ref2 === ':') {\n      return false;\n    } else {\n      return true;\n    }\n  };\n\n  JS_KEYWORDS = ['true', 'false', 'null', 'this', 'new', 'delete', 'typeof', 'in', 'instanceof', 'return', 'throw', 'break', 'continue', 'debugger', 'yield', 'if', 'else', 'switch', 'for', 'while', 'do', 'try', 'catch', 'finally', 'class', 'extends', 'super', 'import', 'export', 'default'];\n  COFFEE_KEYWORDS = ['undefined', 'Infinity', 'NaN', 'then', 'unless', 'until', 'loop', 'of', 'by', 'when'];\n  COFFEE_ALIAS_MAP = {\n    and: '&&',\n    or: '||',\n    is: '==',\n    isnt: '!=',\n    not: '!',\n    yes: 'true',\n    no: 'false',\n    on: 'true',\n    off: 'false'\n  };\n\n  COFFEE_ALIASES = function () {\n    var results;\n    results = [];\n\n    for (key in COFFEE_ALIAS_MAP) {\n      results.push(key);\n    }\n\n    return results;\n  }();\n\n  COFFEE_KEYWORDS = COFFEE_KEYWORDS.concat(COFFEE_ALIASES);\n  RESERVED = ['case', 'function', 'var', 'void', 'with', 'const', 'let', 'enum', 'native', 'implements', 'interface', 'package', 'private', 'protected', 'public', 'static'];\n  STRICT_PROSCRIBED = ['arguments', 'eval'];\n  exports.JS_FORBIDDEN = JS_KEYWORDS.concat(RESERVED).concat(STRICT_PROSCRIBED);\n  BOM = 65279;\n  IDENTIFIER = /^(?!\\d)((?:(?!\\s)[$\\w\\x7f-\\uffff])+)([^\\n\\S]*:(?!:))?/;\n  NUMBER = /^0b[01]+|^0o[0-7]+|^0x[\\da-f]+|^\\d*\\.?\\d+(?:e[+-]?\\d+)?/i;\n  OPERATOR = /^(?:[-=]>|[-+*\\/%<>&|^!?=]=|>>>=?|([-+:])\\1|([&|<>*\\/%])\\2=?|\\?(\\.|::)|\\.{2,3})/;\n  WHITESPACE = /^[^\\n\\S]+/;\n  COMMENT = /^###([^#][\\s\\S]*?)(?:###[^\\n\\S]*|###$)|^(?:\\s*#(?!##[^#]).*)+/;\n  CODE = /^[-=]>/;\n  MULTI_DENT = /^(?:\\n[^\\n\\S]*)+/;\n  JSTOKEN = /^`(?!``)((?:[^`\\\\]|\\\\[\\s\\S])*)`/;\n  HERE_JSTOKEN = /^```((?:[^`\\\\]|\\\\[\\s\\S]|`(?!``))*)```/;\n  STRING_START = /^(?:'''|\"\"\"|'|\")/;\n  STRING_SINGLE = /^(?:[^\\\\']|\\\\[\\s\\S])*/;\n  STRING_DOUBLE = /^(?:[^\\\\\"#]|\\\\[\\s\\S]|\\#(?!\\{))*/;\n  HEREDOC_SINGLE = /^(?:[^\\\\']|\\\\[\\s\\S]|'(?!''))*/;\n  HEREDOC_DOUBLE = /^(?:[^\\\\\"#]|\\\\[\\s\\S]|\"(?!\"\")|\\#(?!\\{))*/;\n  STRING_OMIT = /((?:\\\\\\\\)+)|\\\\[^\\S\\n]*\\n\\s*/g;\n  SIMPLE_STRING_OMIT = /\\s*\\n\\s*/g;\n  HEREDOC_INDENT = /\\n+([^\\n\\S]*)(?=\\S)/g;\n  REGEX = /^\\/(?!\\/)((?:[^[\\/\\n\\\\]|\\\\[^\\n]|\\[(?:\\\\[^\\n]|[^\\]\\n\\\\])*\\])*)(\\/)?/;\n  REGEX_FLAGS = /^\\w*/;\n  VALID_FLAGS = /^(?!.*(.).*\\1)[imguy]*$/;\n  HEREGEX = /^(?:[^\\\\\\/#]|\\\\[\\s\\S]|\\/(?!\\/\\/)|\\#(?!\\{))*/;\n  HEREGEX_OMIT = /((?:\\\\\\\\)+)|\\\\(\\s)|\\s+(?:#.*)?/g;\n  REGEX_ILLEGAL = /^(\\/|\\/{3}\\s*)(\\*)/;\n  POSSIBLY_DIVISION = /^\\/=?\\s/;\n  HERECOMMENT_ILLEGAL = /\\*\\//;\n  LINE_CONTINUER = /^\\s*(?:,|\\??\\.(?![.\\d])|::)/;\n  STRING_INVALID_ESCAPE = /((?:^|[^\\\\])(?:\\\\\\\\)*)\\\\(?:(0[0-7]|[1-7])|(x(?![\\da-fA-F]{2}).{0,2})|(u\\{(?![\\da-fA-F]{1,}\\})[^}]*\\}?)|(u(?!\\{|[\\da-fA-F]{4}).{0,4}))/;\n  REGEX_INVALID_ESCAPE = /((?:^|[^\\\\])(?:\\\\\\\\)*)\\\\(?:(0[0-7])|(x(?![\\da-fA-F]{2}).{0,2})|(u\\{(?![\\da-fA-F]{1,}\\})[^}]*\\}?)|(u(?!\\{|[\\da-fA-F]{4}).{0,4}))/;\n  UNICODE_CODE_POINT_ESCAPE = /(\\\\\\\\)|\\\\u\\{([\\da-fA-F]+)\\}/g;\n  LEADING_BLANK_LINE = /^[^\\n\\S]*\\n/;\n  TRAILING_BLANK_LINE = /\\n[^\\n\\S]*$/;\n  TRAILING_SPACES = /\\s+$/;\n  COMPOUND_ASSIGN = ['-=', '+=', '/=', '*=', '%=', '||=', '&&=', '?=', '<<=', '>>=', '>>>=', '&=', '^=', '|=', '**=', '//=', '%%='];\n  UNARY = ['NEW', 'TYPEOF', 'DELETE', 'DO'];\n  UNARY_MATH = ['!', '~'];\n  SHIFT = ['<<', '>>', '>>>'];\n  COMPARE = ['==', '!=', '<', '>', '<=', '>='];\n  MATH = ['*', '/', '%', '//', '%%'];\n  RELATION = ['IN', 'OF', 'INSTANCEOF'];\n  BOOL = ['TRUE', 'FALSE'];\n  CALLABLE = ['IDENTIFIER', 'PROPERTY', ')', ']', '?', '@', 'THIS', 'SUPER'];\n  INDEXABLE = CALLABLE.concat(['NUMBER', 'INFINITY', 'NAN', 'STRING', 'STRING_END', 'REGEX', 'REGEX_END', 'BOOL', 'NULL', 'UNDEFINED', '}', '::']);\n  NOT_REGEX = INDEXABLE.concat(['++', '--']);\n  LINE_BREAK = ['INDENT', 'OUTDENT', 'TERMINATOR'];\n  INDENTABLE_CLOSERS = [')', '}', ']'];\n  UNFINISHED = ['\\\\', '.', '?.', '?::', 'UNARY', 'MATH', 'UNARY_MATH', '+', '-', '**', 'SHIFT', 'RELATION', 'COMPARE', '&', '^', '|', '&&', '||', 'BIN?', 'THROW', 'EXTENDS', 'DEFAULT'];\n}).call(this);","map":{"version":3,"sources":["/Users/straussj/Documents/react_projects/summer-of-jake/node_modules/coffee-script/lib/coffee-script/lexer.js"],"names":["BOM","BOOL","CALLABLE","CODE","COFFEE_ALIASES","COFFEE_ALIAS_MAP","COFFEE_KEYWORDS","COMMENT","COMPARE","COMPOUND_ASSIGN","HERECOMMENT_ILLEGAL","HEREDOC_DOUBLE","HEREDOC_INDENT","HEREDOC_SINGLE","HEREGEX","HEREGEX_OMIT","HERE_JSTOKEN","IDENTIFIER","INDENTABLE_CLOSERS","INDEXABLE","INVERSES","JSTOKEN","JS_KEYWORDS","LEADING_BLANK_LINE","LINE_BREAK","LINE_CONTINUER","Lexer","MATH","MULTI_DENT","NOT_REGEX","NUMBER","OPERATOR","POSSIBLY_DIVISION","REGEX","REGEX_FLAGS","REGEX_ILLEGAL","REGEX_INVALID_ESCAPE","RELATION","RESERVED","Rewriter","SHIFT","SIMPLE_STRING_OMIT","STRICT_PROSCRIBED","STRING_DOUBLE","STRING_INVALID_ESCAPE","STRING_OMIT","STRING_SINGLE","STRING_START","TRAILING_BLANK_LINE","TRAILING_SPACES","UNARY","UNARY_MATH","UNFINISHED","UNICODE_CODE_POINT_ESCAPE","VALID_FLAGS","WHITESPACE","compact","count","invertLiterate","isForFrom","isUnassignable","key","locationDataToString","ref","ref1","repeat","starts","throwSyntaxError","indexOf","item","i","l","length","slice","require","exports","prototype","tokenize","code","opts","consumed","end","ref2","literate","indent","baseIndent","indebt","outdebt","indents","ends","tokens","seenFor","seenImport","seenExport","importSpecifierList","exportSpecifierList","chunkLine","line","chunkColumn","column","clean","chunk","identifierToken","commentToken","whitespaceToken","lineToken","stringToken","numberToken","regexToken","jsToken","literalToken","getLineAndColumnFromChunk","untilBalanced","index","closeIndentation","pop","error","tag","origin","rewrite","charCodeAt","replace","test","alias","colon","colonOffset","id","idLength","input","match","poppedToken","prev","ref3","ref4","ref5","ref6","ref7","ref8","ref9","tagToken","exec","token","value","call","spaced","toUpperCase","first_line","first_column","lastIndexOf","base","lexedLength","number","numberValue","offset","charAt","parseInt","parseFloat","toString","$","attempt","delimiter","doc","heredoc","indentRegex","quote","regex","matchWithInterpolations","j","len","results","push","join","RegExp","mergeInterpolationTokens","_this","formatString","comment","here","script","string","Math","ceil","body","closed","flags","validateEscapes","isRegex","offsetInChunk","formatRegex","makeToken","formatHeregex","makeDelimitedLiteral","double","diff","noNewlines","size","unfinished","suppressNewlines","newlineToken","outdentToken","moveOut","outdentLength","decreasedIndent","dent","lastIndent","pair","nline","message","skipToken","tagParameters","concat","stack","tok","close","firstToken","lastToken","nested","open","str","strPart","splice","substr","last_line","last_column","options","fn","converted","firstEmptyStringIndex","firstIndex","locationToken","lparen","plusToken","rparen","tokensToPush","apply","wanted","lastLine","lineCount","split","lastCharacter","locationData","replaceUnicodeCodePointEscapes","unicodeCodePointToUnicodeEscapes","codePoint","high","low","toUnicodeEscape","val","floor","escapedBackslash","codePointHex","codePointDecimal","before","hex","invalidEscape","invalidEscapeRegex","octal","unicode","unicodeCodePoint","backslash","nul","lf","cr","ls","ps","other","location","name","displayName","and","or","is","isnt","not","yes","no","on","off","JS_FORBIDDEN"],"mappings":"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","sourcesContent":["// Generated by CoffeeScript 1.12.7\n(function() {\n  var BOM, BOOL, CALLABLE, CODE, COFFEE_ALIASES, COFFEE_ALIAS_MAP, COFFEE_KEYWORDS, COMMENT, COMPARE, COMPOUND_ASSIGN, HERECOMMENT_ILLEGAL, HEREDOC_DOUBLE, HEREDOC_INDENT, HEREDOC_SINGLE, HEREGEX, HEREGEX_OMIT, HERE_JSTOKEN, IDENTIFIER, INDENTABLE_CLOSERS, INDEXABLE, INVERSES, JSTOKEN, JS_KEYWORDS, LEADING_BLANK_LINE, LINE_BREAK, LINE_CONTINUER, Lexer, MATH, MULTI_DENT, NOT_REGEX, NUMBER, OPERATOR, POSSIBLY_DIVISION, REGEX, REGEX_FLAGS, REGEX_ILLEGAL, REGEX_INVALID_ESCAPE, RELATION, RESERVED, Rewriter, SHIFT, SIMPLE_STRING_OMIT, STRICT_PROSCRIBED, STRING_DOUBLE, STRING_INVALID_ESCAPE, STRING_OMIT, STRING_SINGLE, STRING_START, TRAILING_BLANK_LINE, TRAILING_SPACES, UNARY, UNARY_MATH, UNFINISHED, UNICODE_CODE_POINT_ESCAPE, VALID_FLAGS, WHITESPACE, compact, count, invertLiterate, isForFrom, isUnassignable, key, locationDataToString, ref, ref1, repeat, starts, throwSyntaxError,\n    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },\n    slice = [].slice;\n\n  ref = require('./rewriter'), Rewriter = ref.Rewriter, INVERSES = ref.INVERSES;\n\n  ref1 = require('./helpers'), count = ref1.count, starts = ref1.starts, compact = ref1.compact, repeat = ref1.repeat, invertLiterate = ref1.invertLiterate, locationDataToString = ref1.locationDataToString, throwSyntaxError = ref1.throwSyntaxError;\n\n  exports.Lexer = Lexer = (function() {\n    function Lexer() {}\n\n    Lexer.prototype.tokenize = function(code, opts) {\n      var consumed, end, i, ref2;\n      if (opts == null) {\n        opts = {};\n      }\n      this.literate = opts.literate;\n      this.indent = 0;\n      this.baseIndent = 0;\n      this.indebt = 0;\n      this.outdebt = 0;\n      this.indents = [];\n      this.ends = [];\n      this.tokens = [];\n      this.seenFor = false;\n      this.seenImport = false;\n      this.seenExport = false;\n      this.importSpecifierList = false;\n      this.exportSpecifierList = false;\n      this.chunkLine = opts.line || 0;\n      this.chunkColumn = opts.column || 0;\n      code = this.clean(code);\n      i = 0;\n      while (this.chunk = code.slice(i)) {\n        consumed = this.identifierToken() || this.commentToken() || this.whitespaceToken() || this.lineToken() || this.stringToken() || this.numberToken() || this.regexToken() || this.jsToken() || this.literalToken();\n        ref2 = this.getLineAndColumnFromChunk(consumed), this.chunkLine = ref2[0], this.chunkColumn = ref2[1];\n        i += consumed;\n        if (opts.untilBalanced && this.ends.length === 0) {\n          return {\n            tokens: this.tokens,\n            index: i\n          };\n        }\n      }\n      this.closeIndentation();\n      if (end = this.ends.pop()) {\n        this.error(\"missing \" + end.tag, end.origin[2]);\n      }\n      if (opts.rewrite === false) {\n        return this.tokens;\n      }\n      return (new Rewriter).rewrite(this.tokens);\n    };\n\n    Lexer.prototype.clean = function(code) {\n      if (code.charCodeAt(0) === BOM) {\n        code = code.slice(1);\n      }\n      code = code.replace(/\\r/g, '').replace(TRAILING_SPACES, '');\n      if (WHITESPACE.test(code)) {\n        code = \"\\n\" + code;\n        this.chunkLine--;\n      }\n      if (this.literate) {\n        code = invertLiterate(code);\n      }\n      return code;\n    };\n\n    Lexer.prototype.identifierToken = function() {\n      var alias, colon, colonOffset, id, idLength, input, match, poppedToken, prev, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, tag, tagToken;\n      if (!(match = IDENTIFIER.exec(this.chunk))) {\n        return 0;\n      }\n      input = match[0], id = match[1], colon = match[2];\n      idLength = id.length;\n      poppedToken = void 0;\n      if (id === 'own' && this.tag() === 'FOR') {\n        this.token('OWN', id);\n        return id.length;\n      }\n      if (id === 'from' && this.tag() === 'YIELD') {\n        this.token('FROM', id);\n        return id.length;\n      }\n      if (id === 'as' && this.seenImport) {\n        if (this.value() === '*') {\n          this.tokens[this.tokens.length - 1][0] = 'IMPORT_ALL';\n        } else if (ref2 = this.value(), indexOf.call(COFFEE_KEYWORDS, ref2) >= 0) {\n          this.tokens[this.tokens.length - 1][0] = 'IDENTIFIER';\n        }\n        if ((ref3 = this.tag()) === 'DEFAULT' || ref3 === 'IMPORT_ALL' || ref3 === 'IDENTIFIER') {\n          this.token('AS', id);\n          return id.length;\n        }\n      }\n      if (id === 'as' && this.seenExport && ((ref4 = this.tag()) === 'IDENTIFIER' || ref4 === 'DEFAULT')) {\n        this.token('AS', id);\n        return id.length;\n      }\n      if (id === 'default' && this.seenExport && ((ref5 = this.tag()) === 'EXPORT' || ref5 === 'AS')) {\n        this.token('DEFAULT', id);\n        return id.length;\n      }\n      ref6 = this.tokens, prev = ref6[ref6.length - 1];\n      tag = colon || (prev != null) && (((ref7 = prev[0]) === '.' || ref7 === '?.' || ref7 === '::' || ref7 === '?::') || !prev.spaced && prev[0] === '@') ? 'PROPERTY' : 'IDENTIFIER';\n      if (tag === 'IDENTIFIER' && (indexOf.call(JS_KEYWORDS, id) >= 0 || indexOf.call(COFFEE_KEYWORDS, id) >= 0) && !(this.exportSpecifierList && indexOf.call(COFFEE_KEYWORDS, id) >= 0)) {\n        tag = id.toUpperCase();\n        if (tag === 'WHEN' && (ref8 = this.tag(), indexOf.call(LINE_BREAK, ref8) >= 0)) {\n          tag = 'LEADING_WHEN';\n        } else if (tag === 'FOR') {\n          this.seenFor = true;\n        } else if (tag === 'UNLESS') {\n          tag = 'IF';\n        } else if (tag === 'IMPORT') {\n          this.seenImport = true;\n        } else if (tag === 'EXPORT') {\n          this.seenExport = true;\n        } else if (indexOf.call(UNARY, tag) >= 0) {\n          tag = 'UNARY';\n        } else if (indexOf.call(RELATION, tag) >= 0) {\n          if (tag !== 'INSTANCEOF' && this.seenFor) {\n            tag = 'FOR' + tag;\n            this.seenFor = false;\n          } else {\n            tag = 'RELATION';\n            if (this.value() === '!') {\n              poppedToken = this.tokens.pop();\n              id = '!' + id;\n            }\n          }\n        }\n      } else if (tag === 'IDENTIFIER' && this.seenFor && id === 'from' && isForFrom(prev)) {\n        tag = 'FORFROM';\n        this.seenFor = false;\n      }\n      if (tag === 'IDENTIFIER' && indexOf.call(RESERVED, id) >= 0) {\n        this.error(\"reserved word '\" + id + \"'\", {\n          length: id.length\n        });\n      }\n      if (tag !== 'PROPERTY') {\n        if (indexOf.call(COFFEE_ALIASES, id) >= 0) {\n          alias = id;\n          id = COFFEE_ALIAS_MAP[id];\n        }\n        tag = (function() {\n          switch (id) {\n            case '!':\n              return 'UNARY';\n            case '==':\n            case '!=':\n              return 'COMPARE';\n            case 'true':\n            case 'false':\n              return 'BOOL';\n            case 'break':\n            case 'continue':\n            case 'debugger':\n              return 'STATEMENT';\n            case '&&':\n            case '||':\n              return id;\n            default:\n              return tag;\n          }\n        })();\n      }\n      tagToken = this.token(tag, id, 0, idLength);\n      if (alias) {\n        tagToken.origin = [tag, alias, tagToken[2]];\n      }\n      if (poppedToken) {\n        ref9 = [poppedToken[2].first_line, poppedToken[2].first_column], tagToken[2].first_line = ref9[0], tagToken[2].first_column = ref9[1];\n      }\n      if (colon) {\n        colonOffset = input.lastIndexOf(':');\n        this.token(':', ':', colonOffset, colon.length);\n      }\n      return input.length;\n    };\n\n    Lexer.prototype.numberToken = function() {\n      var base, lexedLength, match, number, numberValue, ref2, tag;\n      if (!(match = NUMBER.exec(this.chunk))) {\n        return 0;\n      }\n      number = match[0];\n      lexedLength = number.length;\n      switch (false) {\n        case !/^0[BOX]/.test(number):\n          this.error(\"radix prefix in '\" + number + \"' must be lowercase\", {\n            offset: 1\n          });\n          break;\n        case !/^(?!0x).*E/.test(number):\n          this.error(\"exponential notation in '\" + number + \"' must be indicated with a lowercase 'e'\", {\n            offset: number.indexOf('E')\n          });\n          break;\n        case !/^0\\d*[89]/.test(number):\n          this.error(\"decimal literal '\" + number + \"' must not be prefixed with '0'\", {\n            length: lexedLength\n          });\n          break;\n        case !/^0\\d+/.test(number):\n          this.error(\"octal literal '\" + number + \"' must be prefixed with '0o'\", {\n            length: lexedLength\n          });\n      }\n      base = (function() {\n        switch (number.charAt(1)) {\n          case 'b':\n            return 2;\n          case 'o':\n            return 8;\n          case 'x':\n            return 16;\n          default:\n            return null;\n        }\n      })();\n      numberValue = base != null ? parseInt(number.slice(2), base) : parseFloat(number);\n      if ((ref2 = number.charAt(1)) === 'b' || ref2 === 'o') {\n        number = \"0x\" + (numberValue.toString(16));\n      }\n      tag = numberValue === 2e308 ? 'INFINITY' : 'NUMBER';\n      this.token(tag, number, 0, lexedLength);\n      return lexedLength;\n    };\n\n    Lexer.prototype.stringToken = function() {\n      var $, attempt, delimiter, doc, end, heredoc, i, indent, indentRegex, match, quote, ref2, ref3, regex, token, tokens;\n      quote = (STRING_START.exec(this.chunk) || [])[0];\n      if (!quote) {\n        return 0;\n      }\n      if (this.tokens.length && this.value() === 'from' && (this.seenImport || this.seenExport)) {\n        this.tokens[this.tokens.length - 1][0] = 'FROM';\n      }\n      regex = (function() {\n        switch (quote) {\n          case \"'\":\n            return STRING_SINGLE;\n          case '\"':\n            return STRING_DOUBLE;\n          case \"'''\":\n            return HEREDOC_SINGLE;\n          case '\"\"\"':\n            return HEREDOC_DOUBLE;\n        }\n      })();\n      heredoc = quote.length === 3;\n      ref2 = this.matchWithInterpolations(regex, quote), tokens = ref2.tokens, end = ref2.index;\n      $ = tokens.length - 1;\n      delimiter = quote.charAt(0);\n      if (heredoc) {\n        indent = null;\n        doc = ((function() {\n          var j, len, results;\n          results = [];\n          for (i = j = 0, len = tokens.length; j < len; i = ++j) {\n            token = tokens[i];\n            if (token[0] === 'NEOSTRING') {\n              results.push(token[1]);\n            }\n          }\n          return results;\n        })()).join('#{}');\n        while (match = HEREDOC_INDENT.exec(doc)) {\n          attempt = match[1];\n          if (indent === null || (0 < (ref3 = attempt.length) && ref3 < indent.length)) {\n            indent = attempt;\n          }\n        }\n        if (indent) {\n          indentRegex = RegExp(\"\\\\n\" + indent, \"g\");\n        }\n        this.mergeInterpolationTokens(tokens, {\n          delimiter: delimiter\n        }, (function(_this) {\n          return function(value, i) {\n            value = _this.formatString(value, {\n              delimiter: quote\n            });\n            if (indentRegex) {\n              value = value.replace(indentRegex, '\\n');\n            }\n            if (i === 0) {\n              value = value.replace(LEADING_BLANK_LINE, '');\n            }\n            if (i === $) {\n              value = value.replace(TRAILING_BLANK_LINE, '');\n            }\n            return value;\n          };\n        })(this));\n      } else {\n        this.mergeInterpolationTokens(tokens, {\n          delimiter: delimiter\n        }, (function(_this) {\n          return function(value, i) {\n            value = _this.formatString(value, {\n              delimiter: quote\n            });\n            value = value.replace(SIMPLE_STRING_OMIT, function(match, offset) {\n              if ((i === 0 && offset === 0) || (i === $ && offset + match.length === value.length)) {\n                return '';\n              } else {\n                return ' ';\n              }\n            });\n            return value;\n          };\n        })(this));\n      }\n      return end;\n    };\n\n    Lexer.prototype.commentToken = function() {\n      var comment, here, match;\n      if (!(match = this.chunk.match(COMMENT))) {\n        return 0;\n      }\n      comment = match[0], here = match[1];\n      if (here) {\n        if (match = HERECOMMENT_ILLEGAL.exec(comment)) {\n          this.error(\"block comments cannot contain \" + match[0], {\n            offset: match.index,\n            length: match[0].length\n          });\n        }\n        if (here.indexOf('\\n') >= 0) {\n          here = here.replace(RegExp(\"\\\\n\" + (repeat(' ', this.indent)), \"g\"), '\\n');\n        }\n        this.token('HERECOMMENT', here, 0, comment.length);\n      }\n      return comment.length;\n    };\n\n    Lexer.prototype.jsToken = function() {\n      var match, script;\n      if (!(this.chunk.charAt(0) === '`' && (match = HERE_JSTOKEN.exec(this.chunk) || JSTOKEN.exec(this.chunk)))) {\n        return 0;\n      }\n      script = match[1].replace(/\\\\+(`|$)/g, function(string) {\n        return string.slice(-Math.ceil(string.length / 2));\n      });\n      this.token('JS', script, 0, match[0].length);\n      return match[0].length;\n    };\n\n    Lexer.prototype.regexToken = function() {\n      var body, closed, end, flags, index, match, origin, prev, ref2, ref3, ref4, regex, tokens;\n      switch (false) {\n        case !(match = REGEX_ILLEGAL.exec(this.chunk)):\n          this.error(\"regular expressions cannot begin with \" + match[2], {\n            offset: match.index + match[1].length\n          });\n          break;\n        case !(match = this.matchWithInterpolations(HEREGEX, '///')):\n          tokens = match.tokens, index = match.index;\n          break;\n        case !(match = REGEX.exec(this.chunk)):\n          regex = match[0], body = match[1], closed = match[2];\n          this.validateEscapes(body, {\n            isRegex: true,\n            offsetInChunk: 1\n          });\n          body = this.formatRegex(body, {\n            delimiter: '/'\n          });\n          index = regex.length;\n          ref2 = this.tokens, prev = ref2[ref2.length - 1];\n          if (prev) {\n            if (prev.spaced && (ref3 = prev[0], indexOf.call(CALLABLE, ref3) >= 0)) {\n              if (!closed || POSSIBLY_DIVISION.test(regex)) {\n                return 0;\n              }\n            } else if (ref4 = prev[0], indexOf.call(NOT_REGEX, ref4) >= 0) {\n              return 0;\n            }\n          }\n          if (!closed) {\n            this.error('missing / (unclosed regex)');\n          }\n          break;\n        default:\n          return 0;\n      }\n      flags = REGEX_FLAGS.exec(this.chunk.slice(index))[0];\n      end = index + flags.length;\n      origin = this.makeToken('REGEX', null, 0, end);\n      switch (false) {\n        case !!VALID_FLAGS.test(flags):\n          this.error(\"invalid regular expression flags \" + flags, {\n            offset: index,\n            length: flags.length\n          });\n          break;\n        case !(regex || tokens.length === 1):\n          if (body == null) {\n            body = this.formatHeregex(tokens[0][1]);\n          }\n          this.token('REGEX', \"\" + (this.makeDelimitedLiteral(body, {\n            delimiter: '/'\n          })) + flags, 0, end, origin);\n          break;\n        default:\n          this.token('REGEX_START', '(', 0, 0, origin);\n          this.token('IDENTIFIER', 'RegExp', 0, 0);\n          this.token('CALL_START', '(', 0, 0);\n          this.mergeInterpolationTokens(tokens, {\n            delimiter: '\"',\n            double: true\n          }, this.formatHeregex);\n          if (flags) {\n            this.token(',', ',', index - 1, 0);\n            this.token('STRING', '\"' + flags + '\"', index - 1, flags.length);\n          }\n          this.token(')', ')', end - 1, 0);\n          this.token('REGEX_END', ')', end - 1, 0);\n      }\n      return end;\n    };\n\n    Lexer.prototype.lineToken = function() {\n      var diff, indent, match, noNewlines, size;\n      if (!(match = MULTI_DENT.exec(this.chunk))) {\n        return 0;\n      }\n      indent = match[0];\n      this.seenFor = false;\n      if (!this.importSpecifierList) {\n        this.seenImport = false;\n      }\n      if (!this.exportSpecifierList) {\n        this.seenExport = false;\n      }\n      size = indent.length - 1 - indent.lastIndexOf('\\n');\n      noNewlines = this.unfinished();\n      if (size - this.indebt === this.indent) {\n        if (noNewlines) {\n          this.suppressNewlines();\n        } else {\n          this.newlineToken(0);\n        }\n        return indent.length;\n      }\n      if (size > this.indent) {\n        if (noNewlines) {\n          this.indebt = size - this.indent;\n          this.suppressNewlines();\n          return indent.length;\n        }\n        if (!this.tokens.length) {\n          this.baseIndent = this.indent = size;\n          return indent.length;\n        }\n        diff = size - this.indent + this.outdebt;\n        this.token('INDENT', diff, indent.length - size, size);\n        this.indents.push(diff);\n        this.ends.push({\n          tag: 'OUTDENT'\n        });\n        this.outdebt = this.indebt = 0;\n        this.indent = size;\n      } else if (size < this.baseIndent) {\n        this.error('missing indentation', {\n          offset: indent.length\n        });\n      } else {\n        this.indebt = 0;\n        this.outdentToken(this.indent - size, noNewlines, indent.length);\n      }\n      return indent.length;\n    };\n\n    Lexer.prototype.outdentToken = function(moveOut, noNewlines, outdentLength) {\n      var decreasedIndent, dent, lastIndent, ref2;\n      decreasedIndent = this.indent - moveOut;\n      while (moveOut > 0) {\n        lastIndent = this.indents[this.indents.length - 1];\n        if (!lastIndent) {\n          moveOut = 0;\n        } else if (lastIndent === this.outdebt) {\n          moveOut -= this.outdebt;\n          this.outdebt = 0;\n        } else if (lastIndent < this.outdebt) {\n          this.outdebt -= lastIndent;\n          moveOut -= lastIndent;\n        } else {\n          dent = this.indents.pop() + this.outdebt;\n          if (outdentLength && (ref2 = this.chunk[outdentLength], indexOf.call(INDENTABLE_CLOSERS, ref2) >= 0)) {\n            decreasedIndent -= dent - moveOut;\n            moveOut = dent;\n          }\n          this.outdebt = 0;\n          this.pair('OUTDENT');\n          this.token('OUTDENT', moveOut, 0, outdentLength);\n          moveOut -= dent;\n        }\n      }\n      if (dent) {\n        this.outdebt -= moveOut;\n      }\n      while (this.value() === ';') {\n        this.tokens.pop();\n      }\n      if (!(this.tag() === 'TERMINATOR' || noNewlines)) {\n        this.token('TERMINATOR', '\\n', outdentLength, 0);\n      }\n      this.indent = decreasedIndent;\n      return this;\n    };\n\n    Lexer.prototype.whitespaceToken = function() {\n      var match, nline, prev, ref2;\n      if (!((match = WHITESPACE.exec(this.chunk)) || (nline = this.chunk.charAt(0) === '\\n'))) {\n        return 0;\n      }\n      ref2 = this.tokens, prev = ref2[ref2.length - 1];\n      if (prev) {\n        prev[match ? 'spaced' : 'newLine'] = true;\n      }\n      if (match) {\n        return match[0].length;\n      } else {\n        return 0;\n      }\n    };\n\n    Lexer.prototype.newlineToken = function(offset) {\n      while (this.value() === ';') {\n        this.tokens.pop();\n      }\n      if (this.tag() !== 'TERMINATOR') {\n        this.token('TERMINATOR', '\\n', offset, 0);\n      }\n      return this;\n    };\n\n    Lexer.prototype.suppressNewlines = function() {\n      if (this.value() === '\\\\') {\n        this.tokens.pop();\n      }\n      return this;\n    };\n\n    Lexer.prototype.literalToken = function() {\n      var match, message, origin, prev, ref2, ref3, ref4, ref5, ref6, skipToken, tag, token, value;\n      if (match = OPERATOR.exec(this.chunk)) {\n        value = match[0];\n        if (CODE.test(value)) {\n          this.tagParameters();\n        }\n      } else {\n        value = this.chunk.charAt(0);\n      }\n      tag = value;\n      ref2 = this.tokens, prev = ref2[ref2.length - 1];\n      if (prev && indexOf.call(['='].concat(slice.call(COMPOUND_ASSIGN)), value) >= 0) {\n        skipToken = false;\n        if (value === '=' && ((ref3 = prev[1]) === '||' || ref3 === '&&') && !prev.spaced) {\n          prev[0] = 'COMPOUND_ASSIGN';\n          prev[1] += '=';\n          prev = this.tokens[this.tokens.length - 2];\n          skipToken = true;\n        }\n        if (prev && prev[0] !== 'PROPERTY') {\n          origin = (ref4 = prev.origin) != null ? ref4 : prev;\n          message = isUnassignable(prev[1], origin[1]);\n          if (message) {\n            this.error(message, origin[2]);\n          }\n        }\n        if (skipToken) {\n          return value.length;\n        }\n      }\n      if (value === '{' && this.seenImport) {\n        this.importSpecifierList = true;\n      } else if (this.importSpecifierList && value === '}') {\n        this.importSpecifierList = false;\n      } else if (value === '{' && (prev != null ? prev[0] : void 0) === 'EXPORT') {\n        this.exportSpecifierList = true;\n      } else if (this.exportSpecifierList && value === '}') {\n        this.exportSpecifierList = false;\n      }\n      if (value === ';') {\n        this.seenFor = this.seenImport = this.seenExport = false;\n        tag = 'TERMINATOR';\n      } else if (value === '*' && prev[0] === 'EXPORT') {\n        tag = 'EXPORT_ALL';\n      } else if (indexOf.call(MATH, value) >= 0) {\n        tag = 'MATH';\n      } else if (indexOf.call(COMPARE, value) >= 0) {\n        tag = 'COMPARE';\n      } else if (indexOf.call(COMPOUND_ASSIGN, value) >= 0) {\n        tag = 'COMPOUND_ASSIGN';\n      } else if (indexOf.call(UNARY, value) >= 0) {\n        tag = 'UNARY';\n      } else if (indexOf.call(UNARY_MATH, value) >= 0) {\n        tag = 'UNARY_MATH';\n      } else if (indexOf.call(SHIFT, value) >= 0) {\n        tag = 'SHIFT';\n      } else if (value === '?' && (prev != null ? prev.spaced : void 0)) {\n        tag = 'BIN?';\n      } else if (prev && !prev.spaced) {\n        if (value === '(' && (ref5 = prev[0], indexOf.call(CALLABLE, ref5) >= 0)) {\n          if (prev[0] === '?') {\n            prev[0] = 'FUNC_EXIST';\n          }\n          tag = 'CALL_START';\n        } else if (value === '[' && (ref6 = prev[0], indexOf.call(INDEXABLE, ref6) >= 0)) {\n          tag = 'INDEX_START';\n          switch (prev[0]) {\n            case '?':\n              prev[0] = 'INDEX_SOAK';\n          }\n        }\n      }\n      token = this.makeToken(tag, value);\n      switch (value) {\n        case '(':\n        case '{':\n        case '[':\n          this.ends.push({\n            tag: INVERSES[value],\n            origin: token\n          });\n          break;\n        case ')':\n        case '}':\n        case ']':\n          this.pair(value);\n      }\n      this.tokens.push(token);\n      return value.length;\n    };\n\n    Lexer.prototype.tagParameters = function() {\n      var i, stack, tok, tokens;\n      if (this.tag() !== ')') {\n        return this;\n      }\n      stack = [];\n      tokens = this.tokens;\n      i = tokens.length;\n      tokens[--i][0] = 'PARAM_END';\n      while (tok = tokens[--i]) {\n        switch (tok[0]) {\n          case ')':\n            stack.push(tok);\n            break;\n          case '(':\n          case 'CALL_START':\n            if (stack.length) {\n              stack.pop();\n            } else if (tok[0] === '(') {\n              tok[0] = 'PARAM_START';\n              return this;\n            } else {\n              return this;\n            }\n        }\n      }\n      return this;\n    };\n\n    Lexer.prototype.closeIndentation = function() {\n      return this.outdentToken(this.indent);\n    };\n\n    Lexer.prototype.matchWithInterpolations = function(regex, delimiter) {\n      var close, column, firstToken, index, lastToken, line, nested, offsetInChunk, open, ref2, ref3, ref4, str, strPart, tokens;\n      tokens = [];\n      offsetInChunk = delimiter.length;\n      if (this.chunk.slice(0, offsetInChunk) !== delimiter) {\n        return null;\n      }\n      str = this.chunk.slice(offsetInChunk);\n      while (true) {\n        strPart = regex.exec(str)[0];\n        this.validateEscapes(strPart, {\n          isRegex: delimiter.charAt(0) === '/',\n          offsetInChunk: offsetInChunk\n        });\n        tokens.push(this.makeToken('NEOSTRING', strPart, offsetInChunk));\n        str = str.slice(strPart.length);\n        offsetInChunk += strPart.length;\n        if (str.slice(0, 2) !== '#{') {\n          break;\n        }\n        ref2 = this.getLineAndColumnFromChunk(offsetInChunk + 1), line = ref2[0], column = ref2[1];\n        ref3 = new Lexer().tokenize(str.slice(1), {\n          line: line,\n          column: column,\n          untilBalanced: true\n        }), nested = ref3.tokens, index = ref3.index;\n        index += 1;\n        open = nested[0], close = nested[nested.length - 1];\n        open[0] = open[1] = '(';\n        close[0] = close[1] = ')';\n        close.origin = ['', 'end of interpolation', close[2]];\n        if (((ref4 = nested[1]) != null ? ref4[0] : void 0) === 'TERMINATOR') {\n          nested.splice(1, 1);\n        }\n        tokens.push(['TOKENS', nested]);\n        str = str.slice(index);\n        offsetInChunk += index;\n      }\n      if (str.slice(0, delimiter.length) !== delimiter) {\n        this.error(\"missing \" + delimiter, {\n          length: delimiter.length\n        });\n      }\n      firstToken = tokens[0], lastToken = tokens[tokens.length - 1];\n      firstToken[2].first_column -= delimiter.length;\n      if (lastToken[1].substr(-1) === '\\n') {\n        lastToken[2].last_line += 1;\n        lastToken[2].last_column = delimiter.length - 1;\n      } else {\n        lastToken[2].last_column += delimiter.length;\n      }\n      if (lastToken[1].length === 0) {\n        lastToken[2].last_column -= 1;\n      }\n      return {\n        tokens: tokens,\n        index: offsetInChunk + delimiter.length\n      };\n    };\n\n    Lexer.prototype.mergeInterpolationTokens = function(tokens, options, fn) {\n      var converted, firstEmptyStringIndex, firstIndex, i, j, lastToken, len, locationToken, lparen, plusToken, ref2, rparen, tag, token, tokensToPush, value;\n      if (tokens.length > 1) {\n        lparen = this.token('STRING_START', '(', 0, 0);\n      }\n      firstIndex = this.tokens.length;\n      for (i = j = 0, len = tokens.length; j < len; i = ++j) {\n        token = tokens[i];\n        tag = token[0], value = token[1];\n        switch (tag) {\n          case 'TOKENS':\n            if (value.length === 2) {\n              continue;\n            }\n            locationToken = value[0];\n            tokensToPush = value;\n            break;\n          case 'NEOSTRING':\n            converted = fn.call(this, token[1], i);\n            if (converted.length === 0) {\n              if (i === 0) {\n                firstEmptyStringIndex = this.tokens.length;\n              } else {\n                continue;\n              }\n            }\n            if (i === 2 && (firstEmptyStringIndex != null)) {\n              this.tokens.splice(firstEmptyStringIndex, 2);\n            }\n            token[0] = 'STRING';\n            token[1] = this.makeDelimitedLiteral(converted, options);\n            locationToken = token;\n            tokensToPush = [token];\n        }\n        if (this.tokens.length > firstIndex) {\n          plusToken = this.token('+', '+');\n          plusToken[2] = {\n            first_line: locationToken[2].first_line,\n            first_column: locationToken[2].first_column,\n            last_line: locationToken[2].first_line,\n            last_column: locationToken[2].first_column\n          };\n        }\n        (ref2 = this.tokens).push.apply(ref2, tokensToPush);\n      }\n      if (lparen) {\n        lastToken = tokens[tokens.length - 1];\n        lparen.origin = [\n          'STRING', null, {\n            first_line: lparen[2].first_line,\n            first_column: lparen[2].first_column,\n            last_line: lastToken[2].last_line,\n            last_column: lastToken[2].last_column\n          }\n        ];\n        rparen = this.token('STRING_END', ')');\n        return rparen[2] = {\n          first_line: lastToken[2].last_line,\n          first_column: lastToken[2].last_column,\n          last_line: lastToken[2].last_line,\n          last_column: lastToken[2].last_column\n        };\n      }\n    };\n\n    Lexer.prototype.pair = function(tag) {\n      var lastIndent, prev, ref2, ref3, wanted;\n      ref2 = this.ends, prev = ref2[ref2.length - 1];\n      if (tag !== (wanted = prev != null ? prev.tag : void 0)) {\n        if ('OUTDENT' !== wanted) {\n          this.error(\"unmatched \" + tag);\n        }\n        ref3 = this.indents, lastIndent = ref3[ref3.length - 1];\n        this.outdentToken(lastIndent, true);\n        return this.pair(tag);\n      }\n      return this.ends.pop();\n    };\n\n    Lexer.prototype.getLineAndColumnFromChunk = function(offset) {\n      var column, lastLine, lineCount, ref2, string;\n      if (offset === 0) {\n        return [this.chunkLine, this.chunkColumn];\n      }\n      if (offset >= this.chunk.length) {\n        string = this.chunk;\n      } else {\n        string = this.chunk.slice(0, +(offset - 1) + 1 || 9e9);\n      }\n      lineCount = count(string, '\\n');\n      column = this.chunkColumn;\n      if (lineCount > 0) {\n        ref2 = string.split('\\n'), lastLine = ref2[ref2.length - 1];\n        column = lastLine.length;\n      } else {\n        column += string.length;\n      }\n      return [this.chunkLine + lineCount, column];\n    };\n\n    Lexer.prototype.makeToken = function(tag, value, offsetInChunk, length) {\n      var lastCharacter, locationData, ref2, ref3, token;\n      if (offsetInChunk == null) {\n        offsetInChunk = 0;\n      }\n      if (length == null) {\n        length = value.length;\n      }\n      locationData = {};\n      ref2 = this.getLineAndColumnFromChunk(offsetInChunk), locationData.first_line = ref2[0], locationData.first_column = ref2[1];\n      lastCharacter = length > 0 ? length - 1 : 0;\n      ref3 = this.getLineAndColumnFromChunk(offsetInChunk + lastCharacter), locationData.last_line = ref3[0], locationData.last_column = ref3[1];\n      token = [tag, value, locationData];\n      return token;\n    };\n\n    Lexer.prototype.token = function(tag, value, offsetInChunk, length, origin) {\n      var token;\n      token = this.makeToken(tag, value, offsetInChunk, length);\n      if (origin) {\n        token.origin = origin;\n      }\n      this.tokens.push(token);\n      return token;\n    };\n\n    Lexer.prototype.tag = function() {\n      var ref2, token;\n      ref2 = this.tokens, token = ref2[ref2.length - 1];\n      return token != null ? token[0] : void 0;\n    };\n\n    Lexer.prototype.value = function() {\n      var ref2, token;\n      ref2 = this.tokens, token = ref2[ref2.length - 1];\n      return token != null ? token[1] : void 0;\n    };\n\n    Lexer.prototype.unfinished = function() {\n      var ref2;\n      return LINE_CONTINUER.test(this.chunk) || (ref2 = this.tag(), indexOf.call(UNFINISHED, ref2) >= 0);\n    };\n\n    Lexer.prototype.formatString = function(str, options) {\n      return this.replaceUnicodeCodePointEscapes(str.replace(STRING_OMIT, '$1'), options);\n    };\n\n    Lexer.prototype.formatHeregex = function(str) {\n      return this.formatRegex(str.replace(HEREGEX_OMIT, '$1$2'), {\n        delimiter: '///'\n      });\n    };\n\n    Lexer.prototype.formatRegex = function(str, options) {\n      return this.replaceUnicodeCodePointEscapes(str, options);\n    };\n\n    Lexer.prototype.unicodeCodePointToUnicodeEscapes = function(codePoint) {\n      var high, low, toUnicodeEscape;\n      toUnicodeEscape = function(val) {\n        var str;\n        str = val.toString(16);\n        return \"\\\\u\" + (repeat('0', 4 - str.length)) + str;\n      };\n      if (codePoint < 0x10000) {\n        return toUnicodeEscape(codePoint);\n      }\n      high = Math.floor((codePoint - 0x10000) / 0x400) + 0xD800;\n      low = (codePoint - 0x10000) % 0x400 + 0xDC00;\n      return \"\" + (toUnicodeEscape(high)) + (toUnicodeEscape(low));\n    };\n\n    Lexer.prototype.replaceUnicodeCodePointEscapes = function(str, options) {\n      return str.replace(UNICODE_CODE_POINT_ESCAPE, (function(_this) {\n        return function(match, escapedBackslash, codePointHex, offset) {\n          var codePointDecimal;\n          if (escapedBackslash) {\n            return escapedBackslash;\n          }\n          codePointDecimal = parseInt(codePointHex, 16);\n          if (codePointDecimal > 0x10ffff) {\n            _this.error(\"unicode code point escapes greater than \\\\u{10ffff} are not allowed\", {\n              offset: offset + options.delimiter.length,\n              length: codePointHex.length + 4\n            });\n          }\n          return _this.unicodeCodePointToUnicodeEscapes(codePointDecimal);\n        };\n      })(this));\n    };\n\n    Lexer.prototype.validateEscapes = function(str, options) {\n      var before, hex, invalidEscape, invalidEscapeRegex, match, message, octal, ref2, unicode, unicodeCodePoint;\n      if (options == null) {\n        options = {};\n      }\n      invalidEscapeRegex = options.isRegex ? REGEX_INVALID_ESCAPE : STRING_INVALID_ESCAPE;\n      match = invalidEscapeRegex.exec(str);\n      if (!match) {\n        return;\n      }\n      match[0], before = match[1], octal = match[2], hex = match[3], unicodeCodePoint = match[4], unicode = match[5];\n      message = octal ? \"octal escape sequences are not allowed\" : \"invalid escape sequence\";\n      invalidEscape = \"\\\\\" + (octal || hex || unicodeCodePoint || unicode);\n      return this.error(message + \" \" + invalidEscape, {\n        offset: ((ref2 = options.offsetInChunk) != null ? ref2 : 0) + match.index + before.length,\n        length: invalidEscape.length\n      });\n    };\n\n    Lexer.prototype.makeDelimitedLiteral = function(body, options) {\n      var regex;\n      if (options == null) {\n        options = {};\n      }\n      if (body === '' && options.delimiter === '/') {\n        body = '(?:)';\n      }\n      regex = RegExp(\"(\\\\\\\\\\\\\\\\)|(\\\\\\\\0(?=[1-7]))|\\\\\\\\?(\" + options.delimiter + \")|\\\\\\\\?(?:(\\\\n)|(\\\\r)|(\\\\u2028)|(\\\\u2029))|(\\\\\\\\.)\", \"g\");\n      body = body.replace(regex, function(match, backslash, nul, delimiter, lf, cr, ls, ps, other) {\n        switch (false) {\n          case !backslash:\n            if (options.double) {\n              return backslash + backslash;\n            } else {\n              return backslash;\n            }\n          case !nul:\n            return '\\\\x00';\n          case !delimiter:\n            return \"\\\\\" + delimiter;\n          case !lf:\n            return '\\\\n';\n          case !cr:\n            return '\\\\r';\n          case !ls:\n            return '\\\\u2028';\n          case !ps:\n            return '\\\\u2029';\n          case !other:\n            if (options.double) {\n              return \"\\\\\" + other;\n            } else {\n              return other;\n            }\n        }\n      });\n      return \"\" + options.delimiter + body + options.delimiter;\n    };\n\n    Lexer.prototype.error = function(message, options) {\n      var first_column, first_line, location, ref2, ref3, ref4;\n      if (options == null) {\n        options = {};\n      }\n      location = 'first_line' in options ? options : ((ref3 = this.getLineAndColumnFromChunk((ref2 = options.offset) != null ? ref2 : 0), first_line = ref3[0], first_column = ref3[1], ref3), {\n        first_line: first_line,\n        first_column: first_column,\n        last_column: first_column + ((ref4 = options.length) != null ? ref4 : 1) - 1\n      });\n      return throwSyntaxError(message, location);\n    };\n\n    return Lexer;\n\n  })();\n\n  isUnassignable = function(name, displayName) {\n    if (displayName == null) {\n      displayName = name;\n    }\n    switch (false) {\n      case indexOf.call(slice.call(JS_KEYWORDS).concat(slice.call(COFFEE_KEYWORDS)), name) < 0:\n        return \"keyword '\" + displayName + \"' can't be assigned\";\n      case indexOf.call(STRICT_PROSCRIBED, name) < 0:\n        return \"'\" + displayName + \"' can't be assigned\";\n      case indexOf.call(RESERVED, name) < 0:\n        return \"reserved word '\" + displayName + \"' can't be assigned\";\n      default:\n        return false;\n    }\n  };\n\n  exports.isUnassignable = isUnassignable;\n\n  isForFrom = function(prev) {\n    var ref2;\n    if (prev[0] === 'IDENTIFIER') {\n      if (prev[1] === 'from') {\n        prev[1][0] = 'IDENTIFIER';\n        true;\n      }\n      return true;\n    } else if (prev[0] === 'FOR') {\n      return false;\n    } else if ((ref2 = prev[1]) === '{' || ref2 === '[' || ref2 === ',' || ref2 === ':') {\n      return false;\n    } else {\n      return true;\n    }\n  };\n\n  JS_KEYWORDS = ['true', 'false', 'null', 'this', 'new', 'delete', 'typeof', 'in', 'instanceof', 'return', 'throw', 'break', 'continue', 'debugger', 'yield', 'if', 'else', 'switch', 'for', 'while', 'do', 'try', 'catch', 'finally', 'class', 'extends', 'super', 'import', 'export', 'default'];\n\n  COFFEE_KEYWORDS = ['undefined', 'Infinity', 'NaN', 'then', 'unless', 'until', 'loop', 'of', 'by', 'when'];\n\n  COFFEE_ALIAS_MAP = {\n    and: '&&',\n    or: '||',\n    is: '==',\n    isnt: '!=',\n    not: '!',\n    yes: 'true',\n    no: 'false',\n    on: 'true',\n    off: 'false'\n  };\n\n  COFFEE_ALIASES = (function() {\n    var results;\n    results = [];\n    for (key in COFFEE_ALIAS_MAP) {\n      results.push(key);\n    }\n    return results;\n  })();\n\n  COFFEE_KEYWORDS = COFFEE_KEYWORDS.concat(COFFEE_ALIASES);\n\n  RESERVED = ['case', 'function', 'var', 'void', 'with', 'const', 'let', 'enum', 'native', 'implements', 'interface', 'package', 'private', 'protected', 'public', 'static'];\n\n  STRICT_PROSCRIBED = ['arguments', 'eval'];\n\n  exports.JS_FORBIDDEN = JS_KEYWORDS.concat(RESERVED).concat(STRICT_PROSCRIBED);\n\n  BOM = 65279;\n\n  IDENTIFIER = /^(?!\\d)((?:(?!\\s)[$\\w\\x7f-\\uffff])+)([^\\n\\S]*:(?!:))?/;\n\n  NUMBER = /^0b[01]+|^0o[0-7]+|^0x[\\da-f]+|^\\d*\\.?\\d+(?:e[+-]?\\d+)?/i;\n\n  OPERATOR = /^(?:[-=]>|[-+*\\/%<>&|^!?=]=|>>>=?|([-+:])\\1|([&|<>*\\/%])\\2=?|\\?(\\.|::)|\\.{2,3})/;\n\n  WHITESPACE = /^[^\\n\\S]+/;\n\n  COMMENT = /^###([^#][\\s\\S]*?)(?:###[^\\n\\S]*|###$)|^(?:\\s*#(?!##[^#]).*)+/;\n\n  CODE = /^[-=]>/;\n\n  MULTI_DENT = /^(?:\\n[^\\n\\S]*)+/;\n\n  JSTOKEN = /^`(?!``)((?:[^`\\\\]|\\\\[\\s\\S])*)`/;\n\n  HERE_JSTOKEN = /^```((?:[^`\\\\]|\\\\[\\s\\S]|`(?!``))*)```/;\n\n  STRING_START = /^(?:'''|\"\"\"|'|\")/;\n\n  STRING_SINGLE = /^(?:[^\\\\']|\\\\[\\s\\S])*/;\n\n  STRING_DOUBLE = /^(?:[^\\\\\"#]|\\\\[\\s\\S]|\\#(?!\\{))*/;\n\n  HEREDOC_SINGLE = /^(?:[^\\\\']|\\\\[\\s\\S]|'(?!''))*/;\n\n  HEREDOC_DOUBLE = /^(?:[^\\\\\"#]|\\\\[\\s\\S]|\"(?!\"\")|\\#(?!\\{))*/;\n\n  STRING_OMIT = /((?:\\\\\\\\)+)|\\\\[^\\S\\n]*\\n\\s*/g;\n\n  SIMPLE_STRING_OMIT = /\\s*\\n\\s*/g;\n\n  HEREDOC_INDENT = /\\n+([^\\n\\S]*)(?=\\S)/g;\n\n  REGEX = /^\\/(?!\\/)((?:[^[\\/\\n\\\\]|\\\\[^\\n]|\\[(?:\\\\[^\\n]|[^\\]\\n\\\\])*\\])*)(\\/)?/;\n\n  REGEX_FLAGS = /^\\w*/;\n\n  VALID_FLAGS = /^(?!.*(.).*\\1)[imguy]*$/;\n\n  HEREGEX = /^(?:[^\\\\\\/#]|\\\\[\\s\\S]|\\/(?!\\/\\/)|\\#(?!\\{))*/;\n\n  HEREGEX_OMIT = /((?:\\\\\\\\)+)|\\\\(\\s)|\\s+(?:#.*)?/g;\n\n  REGEX_ILLEGAL = /^(\\/|\\/{3}\\s*)(\\*)/;\n\n  POSSIBLY_DIVISION = /^\\/=?\\s/;\n\n  HERECOMMENT_ILLEGAL = /\\*\\//;\n\n  LINE_CONTINUER = /^\\s*(?:,|\\??\\.(?![.\\d])|::)/;\n\n  STRING_INVALID_ESCAPE = /((?:^|[^\\\\])(?:\\\\\\\\)*)\\\\(?:(0[0-7]|[1-7])|(x(?![\\da-fA-F]{2}).{0,2})|(u\\{(?![\\da-fA-F]{1,}\\})[^}]*\\}?)|(u(?!\\{|[\\da-fA-F]{4}).{0,4}))/;\n\n  REGEX_INVALID_ESCAPE = /((?:^|[^\\\\])(?:\\\\\\\\)*)\\\\(?:(0[0-7])|(x(?![\\da-fA-F]{2}).{0,2})|(u\\{(?![\\da-fA-F]{1,}\\})[^}]*\\}?)|(u(?!\\{|[\\da-fA-F]{4}).{0,4}))/;\n\n  UNICODE_CODE_POINT_ESCAPE = /(\\\\\\\\)|\\\\u\\{([\\da-fA-F]+)\\}/g;\n\n  LEADING_BLANK_LINE = /^[^\\n\\S]*\\n/;\n\n  TRAILING_BLANK_LINE = /\\n[^\\n\\S]*$/;\n\n  TRAILING_SPACES = /\\s+$/;\n\n  COMPOUND_ASSIGN = ['-=', '+=', '/=', '*=', '%=', '||=', '&&=', '?=', '<<=', '>>=', '>>>=', '&=', '^=', '|=', '**=', '//=', '%%='];\n\n  UNARY = ['NEW', 'TYPEOF', 'DELETE', 'DO'];\n\n  UNARY_MATH = ['!', '~'];\n\n  SHIFT = ['<<', '>>', '>>>'];\n\n  COMPARE = ['==', '!=', '<', '>', '<=', '>='];\n\n  MATH = ['*', '/', '%', '//', '%%'];\n\n  RELATION = ['IN', 'OF', 'INSTANCEOF'];\n\n  BOOL = ['TRUE', 'FALSE'];\n\n  CALLABLE = ['IDENTIFIER', 'PROPERTY', ')', ']', '?', '@', 'THIS', 'SUPER'];\n\n  INDEXABLE = CALLABLE.concat(['NUMBER', 'INFINITY', 'NAN', 'STRING', 'STRING_END', 'REGEX', 'REGEX_END', 'BOOL', 'NULL', 'UNDEFINED', '}', '::']);\n\n  NOT_REGEX = INDEXABLE.concat(['++', '--']);\n\n  LINE_BREAK = ['INDENT', 'OUTDENT', 'TERMINATOR'];\n\n  INDENTABLE_CLOSERS = [')', '}', ']'];\n\n  UNFINISHED = ['\\\\', '.', '?.', '?::', 'UNARY', 'MATH', 'UNARY_MATH', '+', '-', '**', 'SHIFT', 'RELATION', 'COMPARE', '&', '^', '|', '&&', '||', 'BIN?', 'THROW', 'EXTENDS', 'DEFAULT'];\n\n}).call(this);\n"]},"metadata":{},"sourceType":"script"}